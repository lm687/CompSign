plot(perturb_infer[,1], type='l')
ggplot(melt(perturb_infer), aes(x=Var1, y=value, col='black'))+
geom_line()+
facet_wrap(.~Var2)+
ggtitle('Perturbation for each signature\n We want to find the most plausible set of changes\n in exposures that lead to these perturbations')
## unlikely that both 1, 2 3 and 4 have changed the same
props[2,]/props[1,]
ggplot(melt(cbind.data.frame(timesteps=(1:Ntimesteps), ilr(props)),
id.vars = 'timesteps'),
aes(x=timesteps, y=value, col='black'))+
geom_line()+
facet_wrap(.~variable)+
ggtitle('ilrs')
library(NMF)
##' trying to find the underlying processes
## change rank to find optimal
nmf_perturb <- nmf(perturb_infer, rank=5)
nmf_perturb4 <- nmf(perturb_infer, rank=4)
image.plot(nmf_perturb4@fit@W)
image.plot(nmf_perturb4@fit@H)
## assign each timepoint to a 'cluster'
changes_over_time <- apply(nmf_perturb4@fit@W, 1, which.max)
times <- apply(cbind(1:(Ntimesteps-1), 2:Ntimesteps), 1, paste, collapse='-')
plot(changes_over_time, type='l')
ggplot(data.frame(time=factor(times, levels=times),
period=factor(changes_over_time),
y=rep(1,Ntimesteps-1)))+
geom_bar(aes(x=time, y=y, fill=period), stat='identity', alpha=0.2, width=1)+
#geom_point(aes(x=time, y=period, col=period))+
geom_line(data=data.frame(melt(data.frame(time=factor(times, levels=times),
perturb_infer),
id.vars='time')),
aes(x=time, y=value, group=variable, col=variable))
#' or could have just found minimal number of breakpoints in the plot of
#' perturbations?
findchanges <- function(x){
# x is a vector. see where there is a change
which(x[2:length(x)]-x[1:(length(x)-1)] != 0)
}
idx_changes <- findchanges(changes_over_time)
changes_minimal <- perturb_infer[c(idx_changes, idx_changes[length(idx_changes)]+1),]
#' Estimate the trajectory
minimise_change <- function(current_row,
previous_row,
previous_change){
.differences <- previous_change-current_row/previous_row
#' if two differences are the same, then say that they haven't changed
#' extend this to similar changes
.tab <- table(.differences)
same <- names(which(.tab > 1))
.which_same <- which(.differences == same)
.ret <- rep(NA, length(current_row))
.ret[.which_same] <- 0
## now we need to distribute the perturbation amongst all other parts
.ret[-.which_same] <- - sum(.differences[.which_same]) - .differences[-.which_same]
return(.ret)
}
wrapper_minimise_change <- function(matrix_minimal_changes){
## this will have to be done with all rows iteratively
last_change <- rep(0,5) ## first is unknown
for(i in 1:(nrow(matrix_minimal_changes)-1)){
.change_proposal <- minimise_change(matrix_minimal_changes[i+1,],
matrix_minimal_changes[i,],
last_change)
last_change <- .change_proposal
print(.change_proposal)
}
}
wrapper_minimise_change(changes_minimal)
changes[findchanges(changes),]
#' any linear combination of changes by multiplying previous prortions by perturb_infer
#' are possible.
#' if two signatures increase or decrease all together, is this less likely
#' that this being due to some other signature decreasing or increasing?
#' tracksig
#' Change of activities: computing maximum change of the signatures in each sample,
#' i.e. difference between maximum and minimum activity of the signature.
#' To test for significance: permute mutations in each sample and run the trajectory
#' estimation on the permuted set
#'
#' script change_points.R has the functions to compute the change points
#'     Actually I would have to get the counts to do their permutation
#'    
#'    
### (now): check, and
### simulate just number of mutations attributed to a signature
increases <- matrix(c(rep(1, Ntimesteps),
rep(1, Ntimesteps),
rep(0, 10), rep(2, Ntimesteps-10),
rep(2, 40), rep(0, Ntimesteps-40),
rep(0, Ntimesteps-20), rep(1, 20)),
byrow = FALSE, ncol=5)
counts <- apply(increases, 2, cumsum)
props_2 <- sweep(counts, 1, rowSums(counts), '/')
colnames(props_2) <- paste0('% of mutations attributable to signature ', 1:ncol(props_2))
rownames(props_2) <- paste0('Timepoint ', 1:nrow(props_2))
createBarplot(props_2, remove_labels = TRUE)
##' How to recover what happened?
##' (what is most likely to have happened?)
##' i.e. reproduce this:
ggplot(melt(increases), aes(x=Var1, y=value, col=as.factor(Var2), group=Var2))+
geom_line()+
facet_wrap(.~Var2, ncol=Nsigs)+
ggtitle('Step change of counts for each signature')
ggsave("../../../results/ProjectDynamics/true_changes.png", width = 10, height = 3)
##' not taking into account the first column, which is all zeroes
##' connecting the timepoints
ggthemr('dust')
plotPCA(ilr(props_2)[,-1], groups = 1:100)+
geom_path(aes(group=1))+
ggtitle('PCA for the relative exposures, and time path')
plotPCA(counts, groups = 1:100)+
geom_path(aes(group=1))+
ggtitle('PCA for the count exposures, and time path')
library(Rtsne)
tSNE <- Rtsne(counts, dims = 2, perplexity=25, verbose=TRUE, max_iter = 500)
ggplot(data.frame(D1 = tSNE$Y[,1], D2 = tSNE$Y[,2], groups = 1:100))+ geom_point(aes(x=D1,y=D2, col=groups))
########################################################################
########################################################################
##' There are infinite possibilities of how the change might have been
##' but which is the most likely?
##'
##' Punctualisation: there are \sum_i=0^n choose(n, i) possible changes
##' With 5 signatures, there could be a change in 5, 4, ..., 0 signatures
##' We have some fit and some penalty for the change compared to the previous change
all_combinations <- function(n){
require(combinat)
#  lapply(1:n, function(n0) lapply(1:n0, function(k) choose(n = 0, k = k)))
.all <- sapply(1:n, function(k){
.tmp_combinat <- combinat::combn(1:n, k)
if(k==n){
.to_return <- list(.tmp_combinat)
}else{
.to_return <- lapply(1:ncol(.tmp_combinat), function(coln) (.tmp_combinat[,coln]))
}
.to_return
})
unlist(.all, recursive = FALSE)
}
## compute fit
## compute change
dynamic_penalty <- function(comp_t1, comp_t2){
## two activities, t1 and t2, which are compositional data, in consecutive timepoints
sum(abs(comp_t2-comp_t1)) ## brute
}
combine_fit_penalty <- function(fit, penalty){
## a sort of bayesian information criterion
fit-penalty
}
## for each timepoint change
infer_perturbations <- function(props){
Nsigs <- ncol(props)
list_hist_max_return_perturb_vector <- c()
for(time_it in 2:nrow(props)){
cat('Timepoint', time_it, '\n')
change_it_ct <- 1
list_combinat <- all_combinations(Nsigs)
combination_fit_penalty <- rep(NA, length(list_combinat))
.hist_max_return_perturb_vector <- c()
for(change_it in list_combinat){
if(length(change_it) == 1){ ## otherwise not implemented
## Minimise error of change due to this perturbation, i.e. maximise cosine similarity.
## CAN THIS ONLY BE DONE FOR ONE VARIABLE TO MINIMISE? gradient descent otherwise?
## can we do this with quadratic programming?
basic_perturbation <- rep(1,Nsigs)
optimal <- optimize(maximum = TRUE, interval = c(1, 20), f = function(pertub_coef){ ## this can be one or multiple
.perturb_vector <- basic_perturbation
.perturb_vector[change_it] <- pertub_coef
cosineSimilarity(as.vector(perturbe(props[time_it-1,], .perturb_vector)), props[time_it,], verbatim = FALSE)
})
.return_perturb_vector <- basic_perturbation
.return_perturb_vector[change_it] <- optimal$maximum
## penalty
if(time_it == 2){
ret_dynamic_penalty <- 0
}else{
ret_dynamic_penalty <- lapply(return_perturb_vector_prev, function(x) dynamic_penalty(x, .return_perturb_vector))
}
## combine the two penalties
.tmp_combination_fit_penalty <- sapply(ret_dynamic_penalty, function(x) combine_fit_penalty(fit = optimal$objective, penalty = x))
# which( sapply(.tmp_combination_fit_penalty, function(x) all.equal(x, max(.tmp_combination_fit_penalty))) ) ## near equality
combination_fit_penalty[change_it_ct] <- max(.tmp_combination_fit_penalty)
## save best fit so far
if(change_it_ct == 1){
.hist_max_return_perturb_vector <- list(cbind.data.frame(time_it, paste0(change_it, collapse=','), pert=.return_perturb_vector))
}else{
if(change_it_ct %in% which.max(combination_fit_penalty)){
.hist_max_return_perturb_vector <- c(.hist_max_return_perturb_vector, list(cbind.data.frame(time_it, paste0(change_it, collapse=','), pert=.return_perturb_vector)))
}
}
}
change_it_ct <- change_it_ct + 1
}
## remove first one if necessary
if(combination_fit_penalty[1] < max(combination_fit_penalty, na.rm = TRUE)){
.hist_max_return_perturb_vector[[1]] <- NULL
}
## many potential good options
list_hist_max_return_perturb_vector <- c(list_hist_max_return_perturb_vector, list(.hist_max_return_perturb_vector))
return_perturb_vector_prev <- lapply(.hist_max_return_perturb_vector, function(x) x$pert)
## should I use the proper vector, or the fitted one?
## I keep the observed vector
}
nonempty <- (sapply(list_hist_max_return_perturb_vector, length) > 0)
.tmp_changes <- do.call('rbind', lapply(list_hist_max_return_perturb_vector[nonempty], function(x) x[[1]][,'pert']))
.tmp_changes
}
tmp_changes <- infer_perturbations(props)
tmp_changes_melt <- melt(tmp_changes)
tmp_changes_melt2 <- rbind(cbind(tmp_changes_melt, type='perturbation'),
cbind(melt(increases), type='true increases'))
tmp_changes_melt2$Var2 <- as.factor(paste0('Signature ', tmp_changes_melt2$Var2))
n <- 60
qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
col_vector = unique(unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals))))
myColors <- col_vector[1:length(levels(tmp_changes_melt2$Var2 ))]
names(myColors) <- levels(tmp_changes_melt2$Var2)
ggplot(tmp_changes_melt2, aes(x=Var1, y=value, col=Var2))+ geom_line(size=1)+
facet_wrap(.~interaction(Var2, type), nrow=2, scales = "free")+
ggtitle("Most likely perturbation\nThese two rows are be the same in a perfect reconstruction")+labs(x='Time', y='Perturbation')+
scale_color_manual(name = "grp",values = myColors)
ggsave("../../../results/ProjectDynamics/most_likely_perturbation_recovered.png", width = 12, height = 5)
plot_with_true <- function(true_change, result_inference, name_plot){
result_inference <- rbind(result_inference[1,],
t(sapply(2:nrow(result_inference), function(r){
result_inference[r,]*result_inference[r-1,]
})))
mod_result_inference <- rbind(rep(1, ncol(result_inference)),
result_inference)
tmp_changes_melt <- melt(mod_result_inference)
tmp_changes_melt2 <- rbind(cbind(tmp_changes_melt, type='Inferred perturbation'),
cbind(melt(true_change), type='True increase'))
tmp_changes_melt2$Var2 <- as.factor(paste0('Signature ', tmp_changes_melt2$Var2))
myColors <- col_vector[1:length(levels(tmp_changes_melt2$Var2 ))]
names(myColors) <- levels(tmp_changes_melt2$Var2)
ggplot(tmp_changes_melt2, aes(x=Var1, y=value, col=Var2))+ geom_line(size=3)+
facet_wrap(.~interaction(Var2, type, sep = '\n'), nrow=2, scales = "free")+
ggtitle("Most likely perturbation\n[These two rows are be the same in a perfect reconstruction]")+labs(x='Time', y='Perturbation')+
scale_color_manual(name = "grp",values = myColors)
ggsave(name_plot, width = 12, height = 5)
}
#----------------------------------------------------------------------#
## Minimal example to see where it goes wrong
counts_minimal <- rbind(rep(1, 6),
c(1,1,2,1,1,1),
#c(1,1,2,1,1,1),
#c(1,1,2,1,1,1),
c(1,1,3,1,1,1),
c(1,1,3,1,1,1),
c(1,1,3,1,1,1)
#c(1,1,2,1,1,1),
#rep(1, 6)
)
props_minimal <- sweep(counts_minimal, 1, rowSums(counts_minimal), '/')
inference_minimal <- infer_perturbations(props_minimal) ## correct
plot_with_true(true_change = (counts_minimal), result_inference = inference_minimal,
name_plot = "../../../results/ProjectDynamics/most_likely_perturbation_recovered_minimal.png")
#----------------------------------------------------------------------#
head(melt(increases))
head(tmp_changes_melt)
##' Dynamic programming?
##' hmm with two types of hidden states:
##' - absolute count
##' - activity for each of the signatures
########################################################################
########################################################################
##' current:
logR_overTime <- lapply(1:nrow(props), function(t) outer(props[t,], props[t,], function(s1,s2) log(s1/s2)))
## whenever there's a 1, it's that the ratio hasn't changed
logR_overTime_subtract <- lapply(2:length(logR_overTime),
function(i) logR_overTime[[i]]/logR_overTime[[i-1]])
library(qgraph)
pdf("~/Desktop/graph.pdf")
for(t in logR_overTime){
cat(t, '\n')
qgraph::qgraph(t, layout=matrix(c(c(1,1),c(4,1),c(1,4),c(4,4),c(2.5,2.5)), byrow = TRUE, ncol=2))
}
dev.off()
##' an attempt by using ilr and such things
par(mfrow=c(1,4))
for(j in 1:(Nsigs-1)){
plot(ilr(props_2)[,j],type='l')
}
ilrBase(props_2)
##' So that means that S1 and S2 vary together (their ratio is constant)
##' ilr2 changes but we know that S1 and S2 change together, so it must
##' be due to S3
##' What if we sequentially amalgamate signatures which we consider
##' to be constant enough?
##' i.e. sequentially amalgamate rows which have total variation ~0
totalvar <- compositions::variation(acomp(props_2))
image.plot(totalvar)
min_totvar <- which(totalvar == min(totalvar), arr.ind = TRUE)
min_totvar <- min_totvar[apply(min_totvar, 1, function(a) !(a[1] == a[2])),]
## so we amalgamate a and 2
new_props <- cbind(rowSums(props_2[,c(1,2)]), props_2[,-c(1,2)])
dev.off()
par(mfrow=c(1,3))
for(j in 1:(ncol(new_props)-1)){
plot(ilr(new_props, V = t(createSignary(4, "(((1,2),3),4)")))[,j],type='l')
}
##' for a while nothing changes
plotPCA(ilr(props_2)[,-1], groups = 1:100)+
geom_path(aes(group=1))+
ggtitle('PCA for the relative exposures, and time path')
## what is the ilr that remains zero? the exposure that are constant?
## can we just do linear regression?
ilr2clr(coef(lm(props_2[,1] ~ ilr(props_2[,-1])))[-1], x = props_2[,-1])
##' to continue
minimise_change(props[2,], props[1,], rep(0, 5))
##' Get the breakpoints inferred through NMF
##' and with these breakpoints to all the combinations of
##' changes that might have been
props_named <- props; rownames(props_named) <- paste0('timepoint ', 1:100); colnames(props_named) <- paste0('s', 1:5)
createBarplot(props_named, remove_labels = TRUE)
idx_changes
props[idx_changes-2,]
props[idx_changes-1,]
props[idx_changes,]
props[idx_changes-4,]/props[idx_changes-3,]
props[idx_changes-3,]/props[idx_changes-2,]
props[idx_changes-2,]/props[idx_changes-1,]
props[idx_changes-1,]/props[idx_changes,]
props[idx_changes,]/props[idx_changes+1,]
### ongoing
################################################
plot_gtern <- function(exposures, colours, title='CNA_12K_TCGA'){
stopifnot(nrow(exposures) == nrow(colours))
stopifnot(ncol(exposures) == 3)
tmp_df <- cbind.data.frame(exposures,
col=colours)
names(tmp_df) <- c('s1', 's2', 's3', 'grp')
ggtern(data=tmp_df,
aes(x=s1, y=s2, z=s3, grp=grp), aes(x,y,z)) +
geom_point(aes(color=grp),shape=20, alpha=1)+
labs(x=paste0('S', sig1), y=paste0('S', sig2), z=paste0('S', sig3))+
scale_fill_gradient(low = "blue", high="gold",
space = "Lab", na.value = "white", guide = "colourbar",
aesthetics = "colour")
#ggtitle(paste("Cancer type: ",cancer_type, "\nSignatures: ", paste0(c(sig1, sig2, sig3), collapse=', '),
#              "\nColour: immune score for ", gsub('_', ' ', col_immune), "\n"))
}
plot_gtern(props)
props
plot_gtern(props, colours = factor(1:nrow(props)))
props
library(CompSign)
plot_gtern(close_data(props, 1:3), colours = factor(1:nrow(props)))
close_data(props, 1:3)
close_data(props, c(1,3, 5))
close_data(props, c(3,5,6))
props
plot_gtern(close_data(props, c(1:3)), colours = factor(1:nrow(props)))
exposures=close_data(props, c(1:3))
colours = factor(1:nrow(props))
stopifnot(nrow(exposures) == nrow(colours))
stopifnot(ncol(exposures) == 3)
tmp_df <- cbind.data.frame(exposures,
col=colours)
names(tmp_df) <- c('s1', 's2', 's3', 'grp')
ggtern(data=tmp_df,
aes(x=s1, y=s2, z=s3, grp=grp), aes(x,y,z)) +
geom_point(aes(color=grp),shape=20, alpha=1)+
labs(x=paste0('S', sig1), y=paste0('S', sig2), z=paste0('S', sig3))+
scale_fill_gradient(low = "blue", high="gold",
space = "Lab", na.value = "white", guide = "colourbar",
aesthetics = "colour")
language=en
Sys.setenv(LANG = "en")
################################################
plot_gtern <- function(exposures, colours, title='CNA_12K_TCGA'){
stopifnot(nrow(exposures) == nrow(colours))
stopifnot(ncol(exposures) == 3)
tmp_df <- cbind.data.frame(exposures,
col=colours)
names(tmp_df) <- c('s1', 's2', 's3', 'grp')
ggtern(data=tmp_df,
aes(x=s1, y=s2, z=s3, grp=grp), aes(x,y,z)) +
geom_point(aes(color=grp),shape=20, alpha=1)+
labs(x=paste0('S', sig1), y=paste0('S', sig2), z=paste0('S', sig3))+
scale_fill_gradient(low = "blue", high="gold",
space = "Lab", na.value = "white", guide = "colourbar",
aesthetics = "colour")
#ggtitle(paste("Cancer type: ",cancer_type, "\nSignatures: ", paste0(c(sig1, sig2, sig3), collapse=', '),
#              "\nColour: immune score for ", gsub('_', ' ', col_immune), "\n"))
}
plot_gtern(close_data(props, c(1:3)), colours = factor(1:nrow(props)))
library(ggtern)
plot_gtern(close_data(props, c(1:3)), colours = factor(1:nrow(props)))
stopifnot(nrow(exposures) == nrow(colours))
stopifnot(ncol(exposures) == 3)
tmp_df <- cbind.data.frame(exposures,
col=colours)
names(tmp_df) <- c('s1', 's2', 's3', 'grp')
ggtern(data=tmp_df,
aes(x=s1, y=s2, z=s3, grp=grp), aes(x,y,z)) +
geom_point(aes(color=grp),shape=20, alpha=1)+
labs(x=paste0('S', sig1), y=paste0('S', sig2), z=paste0('S', sig3))+
scale_fill_gradient(low = "blue", high="gold",
space = "Lab", na.value = "white", guide = "colourbar",
aesthetics = "colour")
sig1
colnames(exposures)
ggtern(data=tmp_df,
aes(x=s1, y=s2, z=s3, grp=grp), aes(x,y,z)) +
geom_point(aes(color=grp),shape=20, alpha=1)+
labs(x=paste0('S', 1), y=paste0('S', 2), z=paste0('S', 2))+
scale_fill_gradient(low = "blue", high="gold",
space = "Lab", na.value = "white", guide = "colourbar",
aesthetics = "colour")
ggtern(data=tmp_df,
aes(x=s1, y=s2, z=s3, grp=as.factor(grp)), aes(x,y,z)) +
geom_point(aes(color=grp),shape=20, alpha=1)+
labs(x=paste0('S', 1), y=paste0('S', 2), z=paste0('S', 2))+
scale_fill_gradient(low = "blue", high="gold",
space = "Lab", na.value = "white", guide = "colourbar",
aesthetics = "colour")
ggtern(data=tmp_df,
aes(x=s1, y=s2, z=s3, grp=as.numeric(grp), aes(x,y,z)) +
geom_point(aes(color=grp),shape=20, alpha=1)+
labs(x=paste0('S', 1), y=paste0('S', 2), z=paste0('S', 2))+
scale_fill_gradient(low = "blue", high="gold",
space = "Lab", na.value = "white", guide = "colourbar",
aesthetics = "colour")
#ggtitle(paste("Cancer type: ",cancer_type, "\nSignatures: ", paste0(c(sig1, sig2, sig3), collapse=', '),
#              "\nColour: immune score for ", gsub('_', ' ', col_immune), "\n"))
}
Sys.setenv(LANG = "en")
library(CompSign)  ## for function <close_data>
library(ggtern)
plot_gtern(close_data(props, c(1:3)), colours = factor(1:nrow(props)))
################################################
############## Time series models ##############
################################################
#' "cozygene/MTV-LMM" for another package
library(vars)
a <- SVAR(VAR(y = props_2), Amat=matrix(NA, 4, 4), Bmat = matrix(NA, 4, 4))
data(Canada)
var.2c <- VAR(Canada, p = 2, type = "const")
amat <- diag(4)
diag(amat) <- NA
amat[2, 1] <- NA
amat[4, 1] <- NA
## Estimation method scoring
SVAR(x = var.2c, estmethod = "scoring", Amat = amat, Bmat = NULL,
max.iter = 100, maxls = 1000, conv.crit = 1.0e-8)
## Estimation method direct
SVAR(x = var.2c, estmethod = "direct", Amat = amat, Bmat = NULL,
hessian = TRUE, method="BFGS")
# }
createBarplot(props_2, remove_labels = TRUE)
## correlation between s1 and s2 in a new way I've thought
## Correlation of first signature vs all others
par(mfrow=c(2,2))
plot(as.vector(ilr(props_2, V = c(1,-1, -1, -1, -1))),        ###
as.vector(ilr(clo(props_2[,-1]), V = c(1,-1, -1, -1))))  ### remove the first component
plot(as.vector(ilr(props_2, V = c(1,-1, -1, -1, -1))),        ###
as.vector(ilr(clo(props_2[,-1]), V = c(-1,1, -1, -1))))  ### remove the first component
plot(as.vector(ilr(props_2, V = c(1,-1, -1, -1, -1))),        ###
as.vector(ilr(clo(props_2[,-1]), V = c(-1,-1, 1, -1))))  ### remove the first component
plot(as.vector(ilr(props_2, V = c(1,-1, -1, -1, -1))),        ###
as.vector(ilr(clo(props_2[,-1]), V = c(-1,-1, -1, 1))))  ### remove the first component
## Yet another alternative (which might be what they use in the balances paper)
plot(as.vector(ilr(clo(props_2[,-2]), V = c(1,-1, -1, -1))),
as.vector(ilr(clo(props_2[,-1]), V = c(1,-1, -1, -1))))
plot(as.vector(ilr(clo(props_2[,-3]), V = c(1,-1, -1, -1))),
as.vector(ilr(clo(props_2[,-1]), V = c(-1, 1, -1, -1))))
ggtern(data=tmp_df,
aes(x=s1, y=s2, z=s3, grp=as.numeric(grp)), aes(x,y,z)) +
geom_point(aes(color=grp),shape=20, alpha=1)+
labs(x=paste0('S', 1), y=paste0('S', 2), z=paste0('S', 2))+
scale_fill_gradient(low = "blue", high="gold",
space = "Lab", na.value = "white", guide = "colourbar",
aesthetics = "colour")
ggtern(data=tmp_df,
aes(x=s1, y=s2, z=s3, grp=as.numeric(grp)), aes(x,y,z)) +
geom_point(aes(color=grp),shape=20, alpha=1)+
labs(x=paste0('S', 1), y=paste0('S', 2), z=paste0('S', 2))#+
colours = (1:nrow(props))
require(ggtern)
stopifnot(nrow(exposures) == nrow(colours))
stopifnot(ncol(exposures) == 3)
tmp_df <- cbind.data.frame(exposures,
col=colours)
names(tmp_df) <- c('s1', 's2', 's3', 'grp')
ggtern(data=tmp_df,
aes(x=s1, y=s2, z=s3, grp=as.numeric(grp)), aes(x,y,z)) +
geom_point(aes(color=grp),shape=20, alpha=1)+
labs(x=paste0('S', 1), y=paste0('S', 2), z=paste0('S', 2))#+
################################################
plot_gtern <- function(exposures, colours, title='CNA_12K_TCGA'){
require(ggtern)
stopifnot(nrow(exposures) == nrow(colours))
stopifnot(ncol(exposures) == 3)
tmp_df <- cbind.data.frame(exposures,
col=colours)
names(tmp_df) <- c('s1', 's2', 's3', 'grp')
ggtern(data=tmp_df,
aes(x=s1, y=s2, z=s3, grp=as.numeric(grp)), aes(x,y,z)) +
geom_point(aes(color=grp),shape=20, alpha=1)+
labs(x=paste0('S', 1), y=paste0('S', 2), z=paste0('S', 2))#+
# scale_fill_gradient(low = "blue", high="gold",
#                     space = "Lab", na.value = "white", guide = "colourbar",
#                     aesthetics = "colour")
#ggtitle(paste("Cancer type: ",cancer_type, "\nSignatures: ", paste0(c(sig1, sig2, sig3), collapse=', '),
#              "\nColour: immune score for ", gsub('_', ' ', col_immune), "\n"))
}
Sys.setenv(LANG = "en")
library(CompSign)  ## for function <close_data>
library(ggtern)
plot_gtern(close_data(props, c(1:3)), colours = (1:nrow(props)))
plot_gtern(close_data(props_2, c(1:3)), colours = (1:nrow(props)))

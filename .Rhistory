alpha = rep(1, length(cat_mut)))
}
par(mfrow=c(1,1))
image(do.call('rbind', sign))
## simutate counts from samples, given exposures per patient
sim_contribution_signatures <- function(){
cat('Computing\n')
nsign <- 10
contribution <- MCMCpack::rdirichlet(1, rep(1, nsign))
SOME_LARGE_NUMBER <- 1e4
sim_exposure <- list()
for(k in 1:nsign){
sim_exposure[[k]] <- createExposureContinuous(transition_matrix = matrix(c(1, 0, 0, 1),
byrow=TRUE, ncol=2),
signature = sign[[k]],
emission_kernel='dummy',
length_out = contribution[k]*SOME_LARGE_NUMBER,
init_val = 1,
random_signature = FALSE,
alpha = 0)
#aaa <- flatten_emitted_fun(sim_exposure[[1]])
#    aaa <- aaa[nrow(aaa),]
## percentage exposure
}
## image(do.call('rbind', sim_exposure))
## alpha = 0: (hidden) chain doesn't move, as shown:
## unique(unlist(lapply(sim_exposure, function(x) x$hiddenchain)))
## we have ten signatures:
## length(sign)
## add counts together
return(list(tab = table(factor(unlist(lapply(sim_exposure, function(x) x$emitted)),
levels=1:Ncat)),
contribution = contribution))
}
##    [Time consuming]    ##
res_sim_contribution_signatures <- replicate(10, sim_contribution_signatures(),
simplify = FALSE)
## plot of different contribution of signatures
par(mfrow=c(2,5))
for(j in 1:10){
plot(res_sim_contribution_signatures[[j]]$tab, type='h')
}
for(j in 1:10){
plot(res_sim_contribution_signatures[[j]]$tab, type='h')
}
lapply(res_sim_contribution_signatures, function(x) x$tab[1])
lapply(res_sim_contribution_signatures, function(x) x$contribution)
pairs(do.call('rbind',
lapply(res_sim_contribution_signatures, function(x) x$contribution)),
pch=19, cex=0.3)
pairs(do.call('rbind',
lapply(res_sim_contribution_signatures, function(x) x$tab[1:9])),
pch=19, cex=0.3)
to_deconv <- do.call('rbind',
lapply(res_sim_contribution_signatures, function(x) x$tab))
to_deconv <- to_deconv[,-97]
colnames(to_deconv) <- cat_mut[-97]
cat_mut <- create_catMut()
cat_mut
rm(list = ls())
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
library(MCMCpack)
library(signeR)
source("../CDA_in_Cancer/code/functions/SimFunctions.R")
rm(list = ls())
library(MCMCpack)
library(signeR)
source("../CDA_in_Cancer/code/functions/SimFunctions.R")
cat_mut <- create_catMut()[-97]
Ncat <- length(cat_mut)
## Create signatures
sign <- list()
for(k in 1:10){
sign[[k]] <- MCMCpack::rdirichlet(n = 1,
alpha = rep(1, length(cat_mut)))
}
## simutate counts from samples, given exposures per patient
sim_contribution_signatures <- function(){
cat('Computing\n')
nsign <- 10
contribution <- MCMCpack::rdirichlet(1, rep(1, nsign))
SOME_LARGE_NUMBER <- 1e4
sim_exposure <- list()
for(k in 1:nsign){
sim_exposure[[k]] <- createExposureContinuous(transition_matrix = matrix(c(1, 0, 0, 1),
byrow=TRUE, ncol=2),
signature = sign[[k]],
emission_kernel='dummy',
length_out = contribution[k]*SOME_LARGE_NUMBER,
init_val = 1,
random_signature = FALSE,
alpha = 0)
#aaa <- flatten_emitted_fun(sim_exposure[[1]])
#    aaa <- aaa[nrow(aaa),]
## percentage exposure
}
## image(do.call('rbind', sim_exposure))
## alpha = 0: (hidden) chain doesn't move, as shown:
## unique(unlist(lapply(sim_exposure, function(x) x$hiddenchain)))
## we have ten signatures:
## length(sign)
## add counts together
return(list(tab = table(factor(unlist(lapply(sim_exposure, function(x) x$emitted)),
levels=1:Ncat)),
contribution = contribution))
}
##    [Time consuming]    ##
res_sim_contribution_signatures <- replicate(10, sim_contribution_signatures(),
simplify = FALSE)
to_deconv <- do.call('rbind',
lapply(res_sim_contribution_signatures, function(x) x$tab))
to_deconv <- to_deconv
colnames(to_deconv) <- cat_mut
rownames(to_deconv) <- paste0('Sample_', 1:nrow(to_deconv))
##                           ##
##       DECONVOLUTION       ##
##                           ##
## Deconvolute with NMF
deconv_with_NMF_raw <- FALSE
deconv_with_package <- TRUE
if(deconv_with_NMF_raw){
nmf_deconv_it <- list()
rmse_vec <- c()
for(i in 1:dim(to_deconv)[2]){
cat('Rank:', i, '\n')
nmf_deconv_it[[i]] <- NMF::nmf(to_deconv,
rank = i,
seed=134)
rmse_vec <- c(rmse_vec,
sqrt(mean(to_deconv-fitted(nmf_deconv_it[[i]]))**2))
}
par(mfrow=c(1,1))
plot(rmse_vec, type='l')
par(mfrow=c(1,2))
image(to_deconv)
image(fitted(nmf_deconv_it[[10]]))
par(mfrow=c(1,1))
require(pheatmap)
pheatmap(to_deconv-fitted(nmf_deconv_it[[10]]))
## what are the reconstructed signatures?
## here I am looking into the signatures when n=10, but from the RMSE
## it doesn't seem like there is much difference
## deconvoluted isgnatures:
dim(nmf_deconv_it[[10]]@fit@H)
## true signatures:
dim(do.call('rbind', sign))
## all signatures
plot(nmf_deconv_it[[10]]@fit@H,
do.call('rbind', sign), pch=19)
##        IMPORTANT: THIS NEEDS TO HAVE THE CONSTRAINT THAT SUM_i=1!!
##        How do they do it?
##        https://www.cell.com/cell-reports/fulltext/S2211-1247(12)00433-0
sum(nmf_deconv_it[[10]]@fit@H[1,])
sum(sign[[1]])
## similarity of samples based on the contribution of each mutational signature
contrib <- do.call('rbind',
lapply(res_sim_contribution_signatures, function(x) x$contribution))
plot(hclust(dist(acomp(contrib))))
}
contrib
deconv_with_NMF_raw
if(deconv_with_NMF_raw){
nmf_deconv_it <- list()
rmse_vec <- c()
for(i in 1:dim(to_deconv)[2]){
cat('Rank:', i, '\n')
nmf_deconv_it[[i]] <- NMF::nmf(to_deconv,
rank = i,
seed=134)
rmse_vec <- c(rmse_vec,
sqrt(mean(to_deconv-fitted(nmf_deconv_it[[i]]))**2))
}
par(mfrow=c(1,1))
plot(rmse_vec, type='l')
par(mfrow=c(1,2))
image(to_deconv)
image(fitted(nmf_deconv_it[[10]]))
par(mfrow=c(1,1))
require(pheatmap)
pheatmap(to_deconv-fitted(nmf_deconv_it[[10]]))
## what are the reconstructed signatures?
## here I am looking into the signatures when n=10, but from the RMSE
## it doesn't seem like there is much difference
## deconvoluted isgnatures:
dim(nmf_deconv_it[[10]]@fit@H)
## true signatures:
dim(do.call('rbind', sign))
## all signatures
plot(nmf_deconv_it[[10]]@fit@H,
do.call('rbind', sign), pch=19)
##        IMPORTANT: THIS NEEDS TO HAVE THE CONSTRAINT THAT SUM_i=1!!
##        How do they do it?
##        https://www.cell.com/cell-reports/fulltext/S2211-1247(12)00433-0
sum(nmf_deconv_it[[10]]@fit@H[1,])
sum(sign[[1]])
## similarity of samples based on the contribution of each mutational signature
contrib <- do.call('rbind',
lapply(res_sim_contribution_signatures, function(x) x$contribution))
plot(hclust(dist(acomp(contrib))))
}else{
###        USE SOME OTHER PAKCAGE FOR SIGNATURE EXTRACTION.
###        some examples of packages:
###        SomaticSignatures: it needs an vranges object and it finds
###                           the flanking bases with a reference
###                           genome (bad for simulation)
###       signeR: doesn't seem to work because of the version
signatures <- signeR(M=to_deconv, Mheader = TRUE, Oppheader = TRUE)
require(pheatmap)
colSums(signatures$Phat) ## how is this not 1?? (constrain because they are prob)
pheatmap(signatures$Phat, cluster_rows = FALSE, cluster_cols = FALSE)
par(mfrow=c(1,2))
pheatmap(to_deconv, cluster_rows = FALSE, cluster_cols = FALSE,
show_rownames = FALSE, show_colnames = FALSE)
pheatmap(t(signatures$Phat %*% signatures$Ehat), cluster_rows = FALSE, cluster_cols = FALSE)
pheatmap0 <- function(x, ...) pheatmap(x, cluster_rows = FALSE, cluster_cols = FALSE, show_rownames = FALSE, show_colnames = FALSE, ...)
signatures_normalised <- sweep(signatures$Phat, 2, colSums(signatures$Phat), '/')
pheatmap0(t(signatures_normalised))
pheatmap0(do.call('rbind', sign))
cos.sim <- function(A, B) {
A = t(signatures_normalised)[A,]
B = do.call('rbind', sign)[B,-97]
return( sum(A*B)/sqrt(sum(A^2)*sum(B^2)) )
}
pheatmap0(outer(1:nrow(t(signatures_normalised)),
1:(nrow(do.call('rbind', sign))),
Vectorize(cos.sim)),
main = 'Cosine similarity between true (simulated) \nand extracted signatures')
}
signatures_normalised
signatures
signatures$Ehat
signatures$Phat
rowSums(signatures$Phat)
diag(rowSums(signatures$Phat))
diag(1/rowSums(signatures$Phat))
exposures_normalised <- signatures$Ehat %*% diag(1/rowSums(signatures$Phat))
dim(signatures$Ehat)
signatures$Phat
colSums(signatures$Phat)
signatures$Phat
dim9signatures$Phat
dim(signatures$Phat)
dim(signatures$Ehat)
phat (sigs)
colSums(signatures$Phat)
diag(colSums(signatures$Phat))
1/diag(colSums(signatures$Phat))
diag(1/colSums(signatures$Phat))
signatures$Phat %*% diag(1/colSums(signatures$Phat))
(signatures$Phat %*% diag(1/colSums(signatures$Phat))) == signatures_normalised
to_deconv <- do.call('rbind',
lapply(res_sim_contribution_signatures, function(x) x$tab))
to_deconv <- to_deconv
colnames(to_deconv) <- cat_mut
rownames(to_deconv) <- paste0('Sample_', 1:nrow(to_deconv))
to_deconv <- do.call('rbind',
lapply(res_sim_contribution_signatures, function(x) x$tab))
colnames(to_deconv) <- cat_mut; rownames(to_deconv) <- paste0('Sample_', 1:nrow(to_deconv))
##                           ##
##       DECONVOLUTION       ##
##                           ##
## Deconvolute with NMF
deconv_with_NMF_raw <- FALSE
##                           ##
##       DECONVOLUTION       ##
##                           ##
nmf_deconv_it
rmse_vec <- c()
##                           ##
##       DECONVOLUTION       ##
##                           ##
rmse_vec <- c()
rank <- 5 ## arbitrary
cat('Rank:', i, '\n')
i <- 5 ## arbitrary rank
cat('Rank:', i, '\n')
nmf_deconv_it[[i]] <- NMF::nmf(to_deconv,
rank = i,
seed=134)
nmf_deconv_it <- NMF::nmf(to_deconv,
rank = i,
seed=134)
rmse_vec <- sqrt(mean(to_deconv-fitted(nmf_deconv_it[[i]]))**2)
rmse_vec <- sqrt(mean(to_deconv-fitted(nmf_deconv_it[[i]]))**2)
rmse_vec <- sqrt(mean(to_deconv-fitted(nmf_deconv_it))**2)
rmse_vec
rmse <- sqrt(mean(to_deconv-fitted(nmf_deconv_it))**2)
par(mfrow=c(1,1))
plot(rmse_vec, type='l')
par(mfrow=c(1,2))
image(to_deconv)
image(fitted(nmf_deconv_it[[10]]))
par(mfrow=c(1,1))
image(fitted(nmf_deconv_it))
par(mfrow=c(1,2))
image(to_deconv)
image(fitted(nmf_deconv_it))
library(fields)
par(mfrow=c(1,2))
image.plot(to_deconv)
image.plot(fitted(nmf_deconv_it))
image.plot(to_deconv, main='Original')
image.plot(fitted(nmf_deconv_it), main='Deconvoluted')
par(mfrow=c(1,1))
require(pheatmap)
pheatmap(to_deconv-fitted(nmf_deconv_it[[10]]))
normalise_NMF_output <- function(raw_sigature_mat, raw_exposure_mat){
## w is exposures
w <- raw_exposure_mat
## h is signatures
h <- raw_sigature_mat
all(w == deconv@fit@W) & all(h == deconv@fit@H)
all( (w %*% h) == fitted(deconv) )
## we wish rowSums of the signature matrix to add up to the unit, as it's probabilities
norm_mat <- diag(1/rowSums(h))
norm_mat2 <- diag(rowSums(h))
par(mfrow=c(1,2))
all.equal(fitted(deconv), w %*% norm_mat2 %*% norm_mat %*% h)
return(list( exposures = (w %*% norm_mat2), signatures = (norm_mat %*% h) ))
}
nmf_deconv_it
normalise_NMF_output(raw_sigature_mat = basis(nmf_deconv_it), raw_exposure_mat = coef(nmf_deconv_it))
normalise_NMF_output <- function(raw_sigature_mat, raw_exposure_mat, fitted_mat){
## w is exposures
w <- raw_exposure_mat
## h is signatures
h <- raw_sigature_mat
## we wish rowSums of the signature matrix to add up to the unit, as it's probabilities
norm_mat <- diag(1/rowSums(h))
norm_mat2 <- diag(rowSums(h))
par(mfrow=c(1,2))
all.equal(fitted_mat, w %*% norm_mat2 %*% norm_mat %*% h)
return(list( exposures = (w %*% norm_mat2), signatures = (norm_mat %*% h) ))
}
normalise_NMF_output <- function(raw_sigature_mat, raw_exposure_mat, fitted_mat){
## w is exposures
w <- raw_exposure_mat
## h is signatures
h <- raw_sigature_mat
## we wish rowSums of the signature matrix to add up to the unit, as it's probabilities
norm_mat <- diag(1/rowSums(h))
norm_mat2 <- diag(rowSums(h))
par(mfrow=c(1,2))
all.equal(fitted_mat, w %*% norm_mat2 %*% norm_mat %*% h)
return(list( exposures = (w %*% norm_mat2), signatures = (norm_mat %*% h) ))
}
normalise_NMF_output(raw_sigature_mat = basis(nmf_deconv_it), raw_exposure_mat = coef(nmf_deconv_it),
fitted_mat = fitted(nmf_deconv_it))
basis(nmf_deconv_it)
coef(nmf_deconv_it)
raw_sigature_mat = basis(nmf_deconv_it);
raw_exposure_mat = coef(nmf_deconv_it);
fitted_mat = fitted(nmf_deconv_it)
## w is exposures
w <- raw_exposure_mat
## h is signatures
h <- raw_sigature_mat
## we wish rowSums of the signature matrix to add up to the unit, as it's probabilities
norm_mat <- diag(1/rowSums(h))
norm_mat2 <- diag(rowSums(h))
par(mfrow=c(1,2))
all.equal(fitted_mat, w %*% norm_mat2 %*% norm_mat %*% h)
## w is exposures
w <- raw_signature_mat
## h is signatures
h <- raw_exposure_mat
## we wish rowSums of the signature matrix to add up to the unit, as it's probabilities
norm_mat <- diag(1/rowSums(h))
norm_mat2 <- diag(rowSums(h))
par(mfrow=c(1,2))
all.equal(fitted_mat, w %*% norm_mat2 %*% norm_mat %*% h)
## w is exposures
w <- raw_exposure_mat
## h is signatures
h <- raw_signature_mat
raw_signature_mat = basis(nmf_deconv_it)
## w is exposures
w <- raw_exposure_mat
## h is signatures
h <- raw_signature_mat
w
## we wish rowSums of the signature matrix to add up to the unit, as it's probabilities
norm_mat <- diag(1/rowSums(h))
norm_mat2 <- diag(rowSums(h))
par(mfrow=c(1,2))
all.equal(fitted_mat, w %*% norm_mat2 %*% norm_mat %*% h)
## w is exposures
w <- raw_signature_mat
## h is signatures
h <- raw_exposure_mat
## we wish rowSums of the signature matrix to add up to the unit, as it's probabilities
norm_mat <- diag(1/rowSums(h))
norm_mat2 <- diag(rowSums(h))
par(mfrow=c(1,2))
all.equal(fitted_mat, w %*% norm_mat2 %*% norm_mat %*% h)
raw_signature_mat
raw_exposure_mat
raw_exposure_mat = basis(nmf_deconv_it),;
raw_signature_mat = coef(nmf_deconv_it)
raw_exposure_mat = basis(nmf_deconv_it);
raw_signature_mat = coef(nmf_deconv_it)
## w is exposures
w <- raw_exposure_mat
## h is signatures
h <- raw_signature_mat
w
h
## we wish rowSums of the signature matrix to add up to the unit, as it's probabilities
norm_mat <- diag(1/rowSums(h))
norm_mat2 <- diag(rowSums(h))
par(mfrow=c(1,2))
all.equal(fitted_mat, w %*% norm_mat2 %*% norm_mat %*% h)
if(!all.equal(fitted_mat, w %*% norm_mat2 %*% norm_mat %*% h)){stop('Problemo')}
normalise_NMF_output <- function(raw_signature_mat, raw_exposure_mat, fitted_mat){
## w is exposures
w <- raw_exposure_mat
## h is signatures
h <- raw_signature_mat
## we wish rowSums of the signature matrix to add up to the unit, as it's probabilities
norm_mat <- diag(1/rowSums(h))
norm_mat2 <- diag(rowSums(h))
par(mfrow=c(1,2))
if(!all.equal(fitted_mat, w %*% norm_mat2 %*% norm_mat %*% h)){stop('Problemo')}
return(list( exposures = (w %*% norm_mat2), signatures = (norm_mat %*% h) ))
}
normalise_NMF_output(raw_exposure_mat = basis(nmf_deconv_it),
raw_signature_mat = coef(nmf_deconv_it),
fitted_mat = fitted(nmf_deconv_it))
renormalised <- normalise_NMF_output(raw_exposure_mat = basis(nmf_deconv_it),
raw_signature_mat = coef(nmf_deconv_it),
fitted_mat = fitted(nmf_deconv_it))
exposures <- renormalised$exposures
signatures <- renormalised$signatures
exposures
fitted(nmf_deconv_it) == exposures%*%signatures
exposures%*%signatures
fitted(nmf_deconv_it)
all.equal(fitted(nmf_deconv_it), exposures%*%signatures)
##' How to get number of mutations attributed to each mutational signature?
to_deconv
exposures
signatures
signatures[1,]
signatures[1,]
exposures
exposures[1,]
signatures[1,]
exposures[1,]
exposures
exposures[1,1] * signatures[1,]
sum(exposures[1,1] * signatures[1,])
(exposures[1,1] * signatures[1,])
signatures[1,]
##for each of the samples
### for each of the signatures
(exposures[1,1] * signatures[1,])
exposures
exposures
exposures
##for each of the samples
### for each of the signatures
lapply(1:5, function(x) (exposures[1,x] * signatures[x,]))
exposures
# x: for each signature
lapply(1:5, function(x) (exposures[1,x] * signatures[x,]))
# x: for each signature
lapply(1:5, function(x) (Reduce(exposures[1,x] * signatures[x,], '+'))
)
# x: for each signature
lapply(1:5, function(x) (Reduce('+', exposures[1,x] * signatures[x,])))
# x: for each signature
lapply(1:10, function(y) lapply(1:5, function(x) (Reduce('+', exposures[y,x] * signatures[x,]))))
lapply(1:5, function(x) lapply(1:10, function(y) (Reduce('+', exposures[y,x] * signatures[x,]))))
# x: for each signature
# y: for each sample
lapply(1:10, function(y) lapply(1:5, function(x) (Reduce('+', exposures[y,x] * signatures[x,]))))
lapply(1:5, function(x) lapply(1:10, function(y) (Reduce('+', exposures[y,x] * signatures[x,]))))
lapply(1:5, function(x) sum(sapply(1:10, function(y) (Reduce('+', exposures[y,x] * signatures[x,])))))
# x: for each signature
# y: for each sample
lapply(1:10, function(y) sum(sapply(1:5, function(x) (Reduce('+', exposures[y,x] * signatures[x,])))))
lapply(1:5, function(x) sum(sapply(1:10, function(y) (Reduce('+', exposures[y,x] * signatures[x,])))))
# x: for each signature
# y: for each sample
lapply(1:10, function(y) sum(sapply(1:5, function(x) (Reduce('+', exposures[y,x] * signatures[x,])))))
exposures
exposures[1,]
exposures
j=96
i=10
exposures[i,]
signatures[,j]
lapply(1:10, function(i) lapply(1:96, function(j) (sum(exposures[i,] * signatures[,j]))))
lapply(1:10, function(i) sapply(1:96, function(j) (sum(exposures[i,] * signatures[,j]))))
do.call('rbind',
lapply(1:10, function(i) sapply(1:96, function(j) (sum(exposures[i,] * signatures[,j])))))
no_attributable_muts <- do.call('rbind',
lapply(1:10, function(i) sapply(1:96, function(j) (sum(exposures[i,] * signatures[,j])))))
dim(no_attributable_muts)
signatures[,j]
no_attributable_muts <- #do.call('rbind',
lapply(1:10, function(i) lapply(1:5, function(k) sapply(1:96, function(j) (sum(exposures[i,k] * signatures[k,j])))))
no_attributable_muts
no_attributable_muts <- #do.call('rbind',
lapply(1:10, function(i) lapply(1:5, function(k) sum(sapply(1:96, function(j) (sum(exposures[i,k] * signatures[k,j]))))))
no_attributable_muts
no_attributable_muts <- do.call('rbind',
lapply(1:10, function(i) sapply(1:5, function(k) sum(sapply(1:96, function(j) (sum(exposures[i,k] * signatures[k,j]))))))
)
no_attributable_muts
exposures
library(CompSign)

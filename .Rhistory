}
give_dummy_colnames <- function(M){
colnames(M) = paste0('R', 1:ncol(M))
M
}
draw_split_tree = function(tree){
if(length(tree[[1]]) == 1){
## i.e. we are only dealing with two samples - last level
return(paste0(tree[!sapply(tree, is.null)], collapse=','))
}else{
paste0("(", draw_split_tree(tree[[1]]), "),(", draw_split_tree(tree[[2]]), ")")
}
}
data = readRDS("../../data/ProjectCNSigs2/TCGA_Exposures_and_BRCA_Status.rds")
data2 = readRDS("../../data/ProjectCNSigs2/BRCA12_Status_TCGA.rds")
data_brca_genes = read.table("../../data/ProjectCNSigs2/TCGA_OVBRCAonly_Exposures_and_BRCA_Status_plusGene.txt", sep = "\t", header = TRUE)
data_dcast = dcast(data, value.var = 'Exposure', Sample+Cancer+Status~Signature)
data_brca_genes = data_brca_genes[match(data_dcast$Sample, data_brca_genes$Sample),]
data_dcast = cbind(data_dcast[,1:3], Gene=data_brca_genes$Gene, data_dcast[,-(1:3)])
bool_metadata = 1:ncol(data_dcast) %in% 1:4
bool_exposures = !bool_metadata
ct_it = list('OV', c(unique(data_dcast[,'Cancer'])[grepl('BRCA', unique(data_dcast[,'Cancer']))]))
lst_heatmap = list()
for(ct in ct_it){
data_dcast_ct_it = data_dcast[data_dcast$Cancer %in% ct,]
lst_heatmap[[paste0(ct, collapse = '_')]] = ComplexHeatmap::Heatmap(t(data_dcast_ct_it[,bool_exposures]),
top_annotation = columnAnnotation(Cancer = as.vector(data_dcast_ct_it[,which(bool_metadata)[2]]),
Status = as.vector(data_dcast_ct_it[,which(bool_metadata)[3]]),
Gene = as.vector(data_dcast_ct_it[,which(bool_metadata)[4]])), name = )
}
data_dcast = data_dcast[data_dcast$Cancer %in% unlist(ct_it),]
data_dcast$Status = droplevels(data_dcast$Status)
table(data_dcast$Status)
df_prop = give_whole_df(mat_exposures = data_dcast[,bool_exposures], metadata = data_dcast[,bool_metadata])
df_clr = give_whole_df(mat_exposures = as(clr(data_dcast[,bool_exposures]), 'matrix'), metadata = data_dcast[,bool_metadata])
## with default basis
df_irl = give_whole_df(mat_exposures = as(ilr(data_dcast[,bool_exposures]), 'matrix'), metadata = data_dcast[,bool_metadata])
# MGLM::MGLMreg( formula(paste0('Status', '~', paste0(df_irl[[2]], collapse = '+'))), data =  df_irl[[1]], )
mylogit <- nnet::multinom( formula(paste0('Gene', '~', paste0(df_prop[[2]], collapse = '+'))),
data = df_prop[[1]], family = "binomial")
summary(mylogit)
z <- summary(mylogit)$coefficients/summary(mylogit)$standard.errors
z
# 2-tailed z test
p <- (1 - pnorm(abs(z), 0, 1)) * 2
p
basis_17 = ilrBase(D = sum(bool_exposures))
par(mfrow=c(3,6), mar = c(1.2, 1, 1.2, 1))
apply(basis_17, 2, plot, type='h', xlab="", ylab="")
## CompSign::giveTree(17))
signary = CompSign::createSignary(nleaves = 17, tree = "((9,((((13,11),10),6),12)),((((8,(15,7)),1),4),(5,((3,((2,17),14)),16))))")
createSignary
## CompSign::giveTree(17))
signary = createSignary(nleaves = 17, tree = "((9,((((13,11),10),6),12)),((((8,(15,7)),1),4),(5,((3,((2,17),14)),16))))")
signary
sums_z = rep(NA, 17)
for(i in 1:17){
# ## start with 1 versus all (logit)
basis = rep(-1, 17)
basis[i] = 1
## normalise to make it orthonormal
## although that doesn't matter (I believe) when we are in the predicting scenario
#(basis)/sqrt(sum(basis**2))
df_irl = give_whole_df(#mat_exposures = as(ilr(data_dcast[,bool_exposures], V = gsi.buildilrBase(W=t(signary))), 'matrix'),
mat_exposures=as(clr(data_dcast[,bool_exposures]), 'matrix') %*% (basis)/sqrt(sum(basis**2)),
metadata = data_dcast[,bool_metadata])
mylogit <- nnet::multinom( formula(paste0('Gene', '~', paste0(df_irl[[2]], collapse = '+'))),
data = df_irl[[1]], family = "binomial", trace=FALSE)
summary(mylogit)
z <- summary(mylogit)$coefficients/summary(mylogit)$standard.errors
## do it for all 17 basis and see what the z-scores are
sums_z[i] = sum(abs(z[,2]))
}
## the best predictors seem to be 2, 1, 3, and maybe 14.
names(sums_z) <- paste0('CS', 1:17)
sort(sums_z, decreasing = TRUE)
run_all_ilr = function(signature_under_consideration, all_signatures_under_consideration, any_previous_predictors){
basis = rep(0, 17) ## these have already been taken into consideration so we don't care about those
basis[all_signatures_under_consideration] = -1 ## thse are the ones we are testing against
basis[signature_under_consideration] = 1 ## this is the part of the composition which we are taking into consideration
## To add: any_previous_predictors into the regression!
df_irl = give_whole_df(mat_exposures=as(clr(data_dcast[,bool_exposures]), 'matrix') %*% basis,
metadata = data_dcast[,bool_metadata])
if(!is.null(any_previous_predictors)){
df_irl[[1]] = cbind(df_irl[[1]], apply(any_previous_predictors, 2, function(sign) as(clr(data_dcast[,which(bool_exposures)]), 'matrix') %*% sign)) ### THIS IS THE OFFENDING ITEM!
df_irl[[2]] = c(df_irl[[2]], colnames(any_previous_predictors))
}
mylogit <- nnet::multinom( formula(paste0('Gene', '~', paste0(df_irl[[2]], collapse = '+'))),
data = df_irl[[1]], family = "binomial", trace=FALSE)
sum(abs(mylogit$residuals))
}
run_with_all_remaining <- function(i, all_signatures_under_consideration, any_previous_predictors){
sapply(i, run_all_ilr,
all_signatures_under_consideration=all_signatures_under_consideration,
any_previous_predictors=any_previous_predictors)
}
give_the_tree = function(any_previous_predictors_init=NULL, all_signatures_under_consideration_init=1:17, all_signatures=1:17, verbatim=FALSE){
if(verbatim) cat('The signatures under consideration are: ', all_signatures_under_consideration_init, '\n')
all_signatures_under_consideration = all_signatures_under_consideration_init
if(length(all_signatures_under_consideration_init) > 2){
## Init first round
any_previous_predictors = any_previous_predictors_init
possible_candidates = all_signatures_under_consideration_init
.it_logistic = run_with_all_remaining(i= possible_candidates,
all_signatures_under_consideration = all_signatures_under_consideration_init,
any_previous_predictors=any_previous_predictors)
## Init vectors etc
number_parts_in_tree = 1
ct_closing = 1
tree = list()
min_AIC = Inf
name_min_AIC = c()
## Recursive until we have found the best group for the split
while(any(.it_logistic < min_AIC)){
if(verbatim) cat('There is a part of the composition which we can add.\n')
## if any of them work better than just using the previous signature alone, add it together, and repeat
## all_signatures_under_consideration = all_signatures_under_consideration ## this doesn't change
## any_previous_predictors = any_previous_predictors ## this doesn't change
## we whould add this one to the same cluster as the previous signature
if(verbatim) cat('Adding', name_min_AIC, '\n')
min_AIC = min(.it_logistic) ## update sum of residuals
name_min_AIC = c(name_min_AIC, possible_candidates[which.min(.it_logistic)])
if(verbatim) cat('\nIterate #', number_parts_in_tree, '\n')
if(verbatim) cat('The signatures under consideration are\n', all_signatures_under_consideration, '\n')
possible_candidates = all_signatures_under_consideration[! (all_signatures_under_consideration %in% c(name_min_AIC))]
.it_logistic = run_with_all_remaining(i = lapply(possible_candidates, function(j) c(name_min_AIC, j)),
all_signatures_under_consideration = all_signatures_under_consideration,
any_previous_predictors = any_previous_predictors)
}
if(verbatim) cat('There is no more part of the composition which we can add. Closing group {', name_min_AIC, '}\n')
new_any_previous_predictors = rep(0, length(all_signatures))
new_any_previous_predictors[(all_signatures_under_consideration_init %in% all_signatures_under_consideration)] = -1
new_any_previous_predictors[(all_signatures_under_consideration_init %in% name_min_AIC)] = 1
names(new_any_previous_predictors) = paste0('CS', all_signatures)
any_previous_predictors = cbind(any_previous_predictors, new_any_previous_predictors)
## any_previous_predictors should be the base
if(verbatim) cat('Closing group', name_min_AIC, '.\n')
## the ones which are on the group which we have selected
a = give_the_tree(any_previous_predictors_init = any_previous_predictors,
all_signatures_under_consideration_init = name_min_AIC)
## the ones which are on the group that is its complement (within the subcomposition)
b = give_the_tree(any_previous_predictors_init = any_previous_predictors,
all_signatures_under_consideration_init = all_signatures_under_consideration[!(all_signatures_under_consideration %in% name_min_AIC)])
}else{
if(length(all_signatures_under_consideration) == 1){
a = all_signatures_under_consideration
b = NULL
}else if(length(all_signatures_under_consideration) == 2){
a = all_signatures_under_consideration[1]
b = all_signatures_under_consideration[2]
}else{
stop('Length of vector <all_signatures_under_consideration> erroneous')
}
}
## now the loop has stopped and we have split the tree into two. Repeat the same for each tree individually
return(list(a, b))
}
give_orthonormal_basis_rw <- function(signary_rw){
r = sum(signary_rw == 1)
s = sum(signary_rw == (-1))
x = sqrt((r*s)/(r+s))
signary_rw[signary_rw == 1] = 1/r*x
signary_rw[signary_rw == -1] = -1/s*x
signary_rw
}
split_tmp = strsplit(drawn_split_tree0, "(?=[/(|/)/,])", perl = TRUE)[[1]]
tree = give_the_tree(any_previous_predictors_init=NULL, all_signatures_under_consideration_init=1:17)
drawn_split_tree0 = draw_split_tree(tree)
drawn_split_tree = paste0("((0),(", drawn_split_tree0, "));")
tree_newick = ape::read.tree(text = paste0(drawn_split_tree))
plot(tree_newick, no.margin=TRUE, edge.width=2)
split_tmp = strsplit(drawn_split_tree0, "(?=[/(|/)/,])", perl = TRUE)[[1]]
bool_rm_par = c(sapply(1:(length(split_tmp)-2), function(i) split_tmp[i] == "(" && split_tmp[i+2] == ")"), c(F,F))
split_tmp[bool_rm_par] = ""
split_tmp[which(bool_rm_par)+2] = ""
drawn_split_tree1 = paste0(split_tmp, collapse = '')
optimal_signary = createSignary(nleaves = 17, tree = drawn_split_tree1)
View(optimal_signary)
optimal_signary_orthonormal = t(apply(optimal_signary, 1, give_orthonormal_basis_rw))
optimal_signary_orthonormal
sapply(1:16, function(i) sum(optimal_signary_orthonormal[i,]*optimal_signary_orthonormal[i,])) ## they do have norm = 1
sapply(2:16, function(i) sum(optimal_signary_orthonormal[1,]*optimal_signary_orthonormal[i,])) ## but they are not orthogonal??
(as(clr(data_dcast[,bool_exposures]), 'matrix') %*% t(optimal_signary_orthonormal))[1:4,1:4]
as(clr( ( as(data_dcast[,bool_exposures], 'matrix') %*% t(optimal_signary_orthonormal) ), 'matrix'))[1:4,1:4]
## clr first
plot(unlist(t(optimal_signary_orthonormal %*% t(as(clr(as(data_dcast[,bool_exposures], 'matrix')), 'matrix')))),
unlist(ilr(data_dcast[,bool_exposures], V = gsi.buildilrBase(t(optimal_signary)))), pch=10, cex=0.4)
run_all_ilr = function(signature_under_consideration, all_signatures_under_consideration, any_previous_predictors){
basis = rep(0, 17) ## these have already been taken into consideration so we don't care about those
basis[all_signatures_under_consideration] = -1 ## thse are the ones we are testing against
basis[signature_under_consideration] = 1 ## this is the part of the composition which we are taking into consideration
orthonormal_basis = give_orthonormal_basis_rw(basis)
## To add: any_previous_predictors into the regression!
df_irl = give_whole_df(mat_exposures=orthonormal_basis %*% t(as(clr(as(data_dcast[,bool_exposures], 'matrix')), 'matrix')),
metadata = data_dcast[,bool_metadata])
if(!is.null(any_previous_predictors)){
df_irl[[1]] = cbind(df_irl[[1]], apply(any_previous_predictors, 2,
function(sign) give_orthonormal_basis_rw(sign) %*% t(as(clr(as(data_dcast[,bool_exposures], 'matrix')), 'matrix'))))
df_irl[[2]] = c(df_irl[[2]], colnames(any_previous_predictors))
}
mylogit <- nnet::multinom( formula(paste0('Gene', '~', paste0(df_irl[[2]], collapse = '+'))),
data = df_irl[[1]], family = "binomial", trace=FALSE)
sum(abs(mylogit$residuals))
}
run_with_all_remaining <- function(i, all_signatures_under_consideration, any_previous_predictors){
sapply(i, run_all_ilr,
all_signatures_under_consideration=all_signatures_under_consideration,
any_previous_predictors=any_previous_predictors)
}
give_the_tree = function(any_previous_predictors_init=NULL, all_signatures_under_consideration_init=1:17, all_signatures=1:17, verbatim=FALSE){
if(verbatim) cat('The signatures under consideration are: ', all_signatures_under_consideration_init, '\n')
all_signatures_under_consideration = all_signatures_under_consideration_init
if(length(all_signatures_under_consideration_init) > 2){
## Init first round
any_previous_predictors = any_previous_predictors_init
possible_candidates = all_signatures_under_consideration_init
.it_logistic = run_with_all_remaining(i= possible_candidates,
all_signatures_under_consideration = all_signatures_under_consideration_init,
any_previous_predictors=any_previous_predictors)
## Init vectors etc
number_parts_in_tree = 1
ct_closing = 1
tree = list()
min_AIC = Inf
name_min_AIC = c()
## Recursive until we have found the best group for the split
while(any(.it_logistic < min_AIC)){
if(verbatim) cat('There is a part of the composition which we can add.\n')
## if any of them work better than just using the previous signature alone, add it together, and repeat
## all_signatures_under_consideration = all_signatures_under_consideration ## this doesn't change
## any_previous_predictors = any_previous_predictors ## this doesn't change
## we whould add this one to the same cluster as the previous signature
if(verbatim) cat('Adding', name_min_AIC, '\n')
min_AIC = min(.it_logistic) ## update sum of residuals
name_min_AIC = c(name_min_AIC, possible_candidates[which.min(.it_logistic)])
if(verbatim) cat('\nIterate #', number_parts_in_tree, '\n')
if(verbatim) cat('The signatures under consideration are\n', all_signatures_under_consideration, '\n')
possible_candidates = all_signatures_under_consideration[! (all_signatures_under_consideration %in% c(name_min_AIC))]
.it_logistic = run_with_all_remaining(i = lapply(possible_candidates, function(j) c(name_min_AIC, j)),
all_signatures_under_consideration = all_signatures_under_consideration,
any_previous_predictors = any_previous_predictors)
}
if(verbatim) cat('There is no more part of the composition which we can add. Closing group {', name_min_AIC, '}\n')
new_any_previous_predictors = rep(0, length(all_signatures))
new_any_previous_predictors[(all_signatures_under_consideration_init %in% all_signatures_under_consideration)] = -1
new_any_previous_predictors[(all_signatures_under_consideration_init %in% name_min_AIC)] = 1
names(new_any_previous_predictors) = paste0('CS', all_signatures)
any_previous_predictors = cbind(any_previous_predictors, new_any_previous_predictors)
## any_previous_predictors should be the base
if(verbatim) cat('Closing group', name_min_AIC, '.\n')
## the ones which are on the group which we have selected
a = give_the_tree(any_previous_predictors_init = any_previous_predictors,
all_signatures_under_consideration_init = name_min_AIC)
## the ones which are on the group that is its complement (within the subcomposition)
b = give_the_tree(any_previous_predictors_init = any_previous_predictors,
all_signatures_under_consideration_init = all_signatures_under_consideration[!(all_signatures_under_consideration %in% name_min_AIC)])
}else{
if(length(all_signatures_under_consideration) == 1){
a = all_signatures_under_consideration
b = NULL
}else if(length(all_signatures_under_consideration) == 2){
a = all_signatures_under_consideration[1]
b = all_signatures_under_consideration[2]
}else{
stop('Length of vector <all_signatures_under_consideration> erroneous')
}
}
## now the loop has stopped and we have split the tree into two. Repeat the same for each tree individually
return(list(a, b))
}
plot(tree_newick, no.margin=TRUE, edge.width=2)
par(mfrow=c(1,1))
pdf("~/Desktop/previous_tree.pdf")
plot(tree_newick, no.margin=TRUE, edge.width=2)
dev.off()
tree = give_the_tree(any_previous_predictors_init=NULL, all_signatures_under_consideration_init=1:17)
any_previous_predictors_init=NULL
all_signatures_under_consideration_init=1:17
if(verbatim) cat('The signatures under consideration are: ', all_signatures_under_consideration_init, '\n')
all_signatures=1:17
verbatim=TRUE
if(verbatim) cat('The signatures under consideration are: ', all_signatures_under_consideration_init, '\n')
all_signatures_under_consideration = all_signatures_under_consideration_init
length(all_signatures_under_consideration_init)
## Init first round
any_previous_predictors = any_previous_predictors_init
possible_candidates = all_signatures_under_consideration_init
.it_logistic = run_with_all_remaining(i= possible_candidates,
all_signatures_under_consideration = all_signatures_under_consideration_init,
any_previous_predictors=any_previous_predictors)
all_signatures_under_consideration_init
any_previous_predictors
all_signatures_under_consideration = all_signatures_under_consideration_init
possible_candidates
i= possible_candidates
signature_under_consideration=i
i
signature_under_consideration=i[1]
i
signature_under_consideration
basis = rep(0, 17) ## these have already been taken into consideration so we don't care about those
basis[all_signatures_under_consideration] = -1 ## thse are the ones we are testing against
basis[signature_under_consideration] = 1 ## this is the part of the composition which we are taking into consideration
basis
orthonormal_basis = give_orthonormal_basis_rw(basis)
orthonormal_basis
t(as(clr(as(data_dcast[,bool_exposures], 'matrix')), 'matrix'))
dim(t(as(clr(as(data_dcast[,bool_exposures], 'matrix')), 'matrix')))
orthonormal_basis %*% t(as(clr(as(data_dcast[,bool_exposures], 'matrix')), 'matrix'))
df_irl = give_whole_df(mat_exposures=orthonormal_basis %*% t(as(clr(as(data_dcast[,bool_exposures], 'matrix')), 'matrix')),
metadata = data_dcast[,bool_metadata])
head(df_irl)
orthonormal_basis %*% t(as(clr(as(data_dcast[,bool_exposures], 'matrix')), 'matrix'))
unlist(orthonormal_basis %*% t(as(clr(as(data_dcast[,bool_exposures], 'matrix')), 'matrix')))
as.vector(orthonormal_basis %*% t(as(clr(as(data_dcast[,bool_exposures], 'matrix')), 'matrix')))
df_irl = give_whole_df(mat_exposures=as.vector(orthonormal_basis %*% t(as(clr(as(data_dcast[,bool_exposures], 'matrix')), 'matrix'))),
metadata = data_dcast[,bool_metadata])
dim(data_dcast[,bool_metadata])
as.matrix(orthonormal_basis %*% t(as(clr(as(data_dcast[,bool_exposures], 'matrix')), 'matrix')))
dim(as.matrix(orthonormal_basis %*% t(as(clr(as(data_dcast[,bool_exposures], 'matrix')), 'matrix'))))
df_irl = give_whole_df(mat_exposures=t(as.matrix(orthonormal_basis %*% t(as(clr(as(data_dcast[,bool_exposures], 'matrix')), 'matrix')))),
metadata = data_dcast[,bool_metadata])
head(df_irl)
if(!is.null(any_previous_predictors)){
df_irl[[1]] = cbind(df_irl[[1]], apply(any_previous_predictors, 2,
function(sign) give_orthonormal_basis_rw(sign) %*% t(as(clr(as(data_dcast[,bool_exposures], 'matrix')), 'matrix'))))
df_irl[[2]] = c(df_irl[[2]], colnames(any_previous_predictors))
}
mylogit <- nnet::multinom( formula(paste0('Gene', '~', paste0(df_irl[[2]], collapse = '+'))),
data = df_irl[[1]], family = "binomial", trace=FALSE)
sum(abs(mylogit$residuals))
run_all_ilr = function(signature_under_consideration, all_signatures_under_consideration, any_previous_predictors){
basis = rep(0, 17) ## these have already been taken into consideration so we don't care about those
basis[all_signatures_under_consideration] = -1 ## thse are the ones we are testing against
basis[signature_under_consideration] = 1 ## this is the part of the composition which we are taking into consideration
orthonormal_basis = give_orthonormal_basis_rw(basis)
## To add: any_previous_predictors into the regression!
df_irl = give_whole_df(mat_exposures=t(as.matrix(orthonormal_basis %*% t(as(clr(as(data_dcast[,bool_exposures], 'matrix')), 'matrix')))),
metadata = data_dcast[,bool_metadata])
if(!is.null(any_previous_predictors)){
df_irl[[1]] = cbind(df_irl[[1]], apply(any_previous_predictors, 2,
function(sign) give_orthonormal_basis_rw(sign) %*% t(as(clr(as(data_dcast[,bool_exposures], 'matrix')), 'matrix'))))
df_irl[[2]] = c(df_irl[[2]], colnames(any_previous_predictors))
}
mylogit <- nnet::multinom( formula(paste0('Gene', '~', paste0(df_irl[[2]], collapse = '+'))),
data = df_irl[[1]], family = "binomial", trace=FALSE)
sum(abs(mylogit$residuals))
}
.it_logistic = run_with_all_remaining(i= possible_candidates,
all_signatures_under_consideration = all_signatures_under_consideration_init,
any_previous_predictors=any_previous_predictors)
.it_logistic
## Init vectors etc
number_parts_in_tree = 1
ct_closing = 1
tree = list()
min_AIC = Inf
name_min_AIC = c()
any(.it_logistic < min_AIC)
if(verbatim) cat('There is a part of the composition which we can add.\n')
## if any of them work better than just using the previous signature alone, add it together, and repeat
## all_signatures_under_consideration = all_signatures_under_consideration ## this doesn't change
## any_previous_predictors = any_previous_predictors ## this doesn't change
## we whould add this one to the same cluster as the previous signature
if(verbatim) cat('Adding', name_min_AIC, '\n')
min_AIC = min(.it_logistic) ## update sum of residuals
name_min_AIC = c(name_min_AIC, possible_candidates[which.min(.it_logistic)])
if(verbatim) cat('\nIterate #', number_parts_in_tree, '\n')
if(verbatim) cat('The signatures under consideration are\n', all_signatures_under_consideration, '\n')
possible_candidates = all_signatures_under_consideration[! (all_signatures_under_consideration %in% c(name_min_AIC))]
.it_logistic = run_with_all_remaining(i = lapply(possible_candidates, function(j) c(name_min_AIC, j)),
all_signatures_under_consideration = all_signatures_under_consideration,
any_previous_predictors = any_previous_predictors)
any_previous_predictors
any(.it_logistic < min_AIC)
i
if(verbatim) cat('There is a part of the composition which we can add.\n')
## if any of them work better than just using the previous signature alone, add it together, and repeat
## all_signatures_under_consideration = all_signatures_under_consideration ## this doesn't change
## any_previous_predictors = any_previous_predictors ## this doesn't change
## we whould add this one to the same cluster as the previous signature
if(verbatim) cat('Adding', name_min_AIC, '\n')
min_AIC = min(.it_logistic) ## update sum of residuals
name_min_AIC = c(name_min_AIC, possible_candidates[which.min(.it_logistic)])
if(verbatim) cat('\nIterate #', number_parts_in_tree, '\n')
if(verbatim) cat('The signatures under consideration are\n', all_signatures_under_consideration, '\n')
possible_candidates = all_signatures_under_consideration[! (all_signatures_under_consideration %in% c(name_min_AIC))]
.it_logistic = run_with_all_remaining(i = lapply(possible_candidates, function(j) c(name_min_AIC, j)),
all_signatures_under_consideration = all_signatures_under_consideration,
any_previous_predictors = any_previous_predictors)
name_min_AIC
any(.it_logistic < min_AIC)
if(verbatim) cat('There is a part of the composition which we can add.\n')
## if any of them work better than just using the previous signature alone, add it together, and repeat
## all_signatures_under_consideration = all_signatures_under_consideration ## this doesn't change
## any_previous_predictors = any_previous_predictors ## this doesn't change
## we whould add this one to the same cluster as the previous signature
if(verbatim) cat('Adding', name_min_AIC, '\n')
min_AIC = min(.it_logistic) ## update sum of residuals
name_min_AIC = c(name_min_AIC, possible_candidates[which.min(.it_logistic)])
if(verbatim) cat('\nIterate #', number_parts_in_tree, '\n')
if(verbatim) cat('The signatures under consideration are\n', all_signatures_under_consideration, '\n')
possible_candidates = all_signatures_under_consideration[! (all_signatures_under_consideration %in% c(name_min_AIC))]
.it_logistic = run_with_all_remaining(i = lapply(possible_candidates, function(j) c(name_min_AIC, j)),
all_signatures_under_consideration = all_signatures_under_consideration,
any_previous_predictors = any_previous_predictors)
any(.it_logistic < min_AIC)
if(verbatim) cat('There is no more part of the composition which we can add. Closing group {', name_min_AIC, '}\n')
new_any_previous_predictors = rep(0, length(all_signatures))
new_any_previous_predictors[(all_signatures_under_consideration_init %in% all_signatures_under_consideration)] = -1
new_any_previous_predictors[(all_signatures_under_consideration_init %in% name_min_AIC)] = 1
names(new_any_previous_predictors) = paste0('CS', all_signatures)
any_previous_predictors = cbind(any_previous_predictors, new_any_previous_predictors)
## any_previous_predictors should be the base
if(verbatim) cat('Closing group', name_min_AIC, '.\n')
## the ones which are on the group which we have selected
a = give_the_tree(any_previous_predictors_init = any_previous_predictors,
all_signatures_under_consideration_init = name_min_AIC)
## the ones which are on the group that is its complement (within the subcomposition)
b = give_the_tree(any_previous_predictors_init = any_previous_predictors,
all_signatures_under_consideration_init = all_signatures_under_consideration[!(all_signatures_under_consideration %in% name_min_AIC)])
run_all_ilr = function(signature_under_consideration, all_signatures_under_consideration, any_previous_predictors){
basis = rep(0, 17) ## these have already been taken into consideration so we don't care about those
basis[all_signatures_under_consideration] = -1 ## thse are the ones we are testing against
basis[signature_under_consideration] = 1 ## this is the part of the composition which we are taking into consideration
orthonormal_basis = give_orthonormal_basis_rw(basis)
## To add: any_previous_predictors into the regression!
df_irl = give_whole_df(mat_exposures=t(as.matrix(orthonormal_basis %*% t(as(clr(as(data_dcast[,bool_exposures], 'matrix')), 'matrix')))),
metadata = data_dcast[,bool_metadata])
if(!is.null(any_previous_predictors)){
df_irl[[1]] = cbind(df_irl[[1]], apply(any_previous_predictors, 2,
function(sign) give_orthonormal_basis_rw(sign) %*% t(as(clr(as(data_dcast[,bool_exposures], 'matrix')), 'matrix'))))
df_irl[[2]] = c(df_irl[[2]], colnames(any_previous_predictors))
}
mylogit <- nnet::multinom( formula(paste0('Gene', '~', paste0(df_irl[[2]], collapse = '+'))),
data = df_irl[[1]], family = "binomial", trace=FALSE)
sum(abs(mylogit$residuals))
}
run_with_all_remaining <- function(i, all_signatures_under_consideration, any_previous_predictors){
sapply(i, run_all_ilr,
all_signatures_under_consideration=all_signatures_under_consideration,
any_previous_predictors=any_previous_predictors)
}
give_the_tree = function(any_previous_predictors_init=NULL, all_signatures_under_consideration_init=1:17, all_signatures=1:17, verbatim=FALSE){
if(verbatim) cat('The signatures under consideration are: ', all_signatures_under_consideration_init, '\n')
all_signatures_under_consideration = all_signatures_under_consideration_init
if(length(all_signatures_under_consideration_init) > 2){
## Init first round
any_previous_predictors = any_previous_predictors_init
possible_candidates = all_signatures_under_consideration_init
.it_logistic = run_with_all_remaining(i= possible_candidates,
all_signatures_under_consideration = all_signatures_under_consideration_init,
any_previous_predictors=any_previous_predictors)
## Init vectors etc
number_parts_in_tree = 1
ct_closing = 1
tree = list()
min_AIC = Inf
name_min_AIC = c()
## Recursive until we have found the best group for the split
while(any(.it_logistic < min_AIC)){
if(verbatim) cat('There is a part of the composition which we can add.\n')
## if any of them work better than just using the previous signature alone, add it together, and repeat
## all_signatures_under_consideration = all_signatures_under_consideration ## this doesn't change
## any_previous_predictors = any_previous_predictors ## this doesn't change
## we whould add this one to the same cluster as the previous signature
if(verbatim) cat('Adding', name_min_AIC, '\n')
min_AIC = min(.it_logistic) ## update sum of residuals
name_min_AIC = c(name_min_AIC, possible_candidates[which.min(.it_logistic)])
if(verbatim) cat('\nIterate #', number_parts_in_tree, '\n')
if(verbatim) cat('The signatures under consideration are\n', all_signatures_under_consideration, '\n')
possible_candidates = all_signatures_under_consideration[! (all_signatures_under_consideration %in% c(name_min_AIC))]
.it_logistic = run_with_all_remaining(i = lapply(possible_candidates, function(j) c(name_min_AIC, j)),
all_signatures_under_consideration = all_signatures_under_consideration,
any_previous_predictors = any_previous_predictors)
}
if(verbatim) cat('There is no more part of the composition which we can add. Closing group {', name_min_AIC, '}\n')
new_any_previous_predictors = rep(0, length(all_signatures))
new_any_previous_predictors[(all_signatures_under_consideration_init %in% all_signatures_under_consideration)] = -1
new_any_previous_predictors[(all_signatures_under_consideration_init %in% name_min_AIC)] = 1
names(new_any_previous_predictors) = paste0('CS', all_signatures)
any_previous_predictors = cbind(any_previous_predictors, new_any_previous_predictors)
## any_previous_predictors should be the base
if(verbatim) cat('Closing group', name_min_AIC, '.\n')
## the ones which are on the group which we have selected
a = give_the_tree(any_previous_predictors_init = any_previous_predictors,
all_signatures_under_consideration_init = name_min_AIC)
## the ones which are on the group that is its complement (within the subcomposition)
b = give_the_tree(any_previous_predictors_init = any_previous_predictors,
all_signatures_under_consideration_init = all_signatures_under_consideration[!(all_signatures_under_consideration %in% name_min_AIC)])
}else{
if(length(all_signatures_under_consideration) == 1){
a = all_signatures_under_consideration
b = NULL
}else if(length(all_signatures_under_consideration) == 2){
a = all_signatures_under_consideration[1]
b = all_signatures_under_consideration[2]
}else{
stop('Length of vector <all_signatures_under_consideration> erroneous')
}
}
## now the loop has stopped and we have split the tree into two. Repeat the same for each tree individually
return(list(a, b))
}
tree = give_the_tree(any_previous_predictors_init=NULL, all_signatures_under_consideration_init=1:17)
par(mfrow=c(1,1))
tree = give_the_tree(any_previous_predictors_init=NULL, all_signatures_under_consideration_init=1:17)
drawn_split_tree0 = draw_split_tree(tree)
drawn_split_tree = paste0("((0),(", drawn_split_tree0, "));")
tree_newick = ape::read.tree(text = paste0(drawn_split_tree))
plot(tree_newick, no.margin=TRUE, edge.width=2)
library(knitr)

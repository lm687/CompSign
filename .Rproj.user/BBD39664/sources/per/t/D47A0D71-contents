## 1. Simulate signatures
## 2. Simulate mutations for each signature, given some exposures
## 3. With NMF, try to recover the signatures
## 4. Compare output

##      this might be redundant. check simulate_exposures.Rnw
rm(list = ls())

library(MCMCpack)
library(signeR)
source("Documents/CantabPhD/CDA_in_Cancer/code/functions/various_functions_simulation.R")

cat_mut <- create_catMut()
Ncat <- length(cat_mut)

## Create signatures
sign <- list()
for(k in 1:10){
  sign[[k]] <- MCMCpack::rdirichlet(n = 1,
                                    alpha = rep(1, length(cat_mut)))
}

par(mfrow=c(1,1))
image(do.call('rbind', sign))


## simutate counts from samples, given exposures per patient
sim_contribution_signatures <- function(){
  cat('Computing\n')
  nsign <- 10
  contribution <- MCMCpack::rdirichlet(1, rep(1, nsign))
  SOME_LARGE_NUMBER <- 1e4
  sim_exposure <- list()
  for(k in 1:nsign){
    sim_exposure[[k]] <- createExposureContinuous(transition_matrix = matrix(c(1, 0, 0, 1),
                                                                             byrow=TRUE, ncol=2),
                                                  signature = sign[[k]],
                                                  emission_kernel='dummy',
                                                  length_out = contribution[k]*SOME_LARGE_NUMBER,
                                                  init_val = 1,
                                                  random_signature = FALSE,
                                                  alpha = 0)
    #aaa <- flatten_emitted_fun(sim_exposure[[1]])
#    aaa <- aaa[nrow(aaa),]
    
    ## percentage exposure
    
  }
  ## image(do.call('rbind', sim_exposure))
  
  ## alpha = 0: (hidden) chain doesn't move, as shown:
  ## unique(unlist(lapply(sim_exposure, function(x) x$hiddenchain)))
  
  ## we have ten signatures:
  ## length(sign)
  
  ## add counts together
  return(list(tab = table(factor(unlist(lapply(sim_exposure, function(x) x$emitted)),
                                 levels=1:Ncat)),
              contribution = contribution))
  
}

##    [Time consuming]    ##
res_sim_contribution_signatures <- replicate(10, sim_contribution_signatures(),
                                             simplify = FALSE)
## plot of different contribution of signatures
par(mfrow=c(2,5))
for(j in 1:10){
  plot(res_sim_contribution_signatures[[j]]$tab, type='h')
}

lapply(res_sim_contribution_signatures, function(x) x$tab[1])
lapply(res_sim_contribution_signatures, function(x) x$contribution)

pairs(do.call('rbind',
              lapply(res_sim_contribution_signatures, function(x) x$contribution)),
      pch=19, cex=0.3)

pairs(do.call('rbind',
              lapply(res_sim_contribution_signatures, function(x) x$tab[1:9])),
      pch=19, cex=0.3)


to_deconv <- do.call('rbind',
                     lapply(res_sim_contribution_signatures, function(x) x$tab))
to_deconv <- to_deconv[,-97]
colnames(to_deconv) <- cat_mut[-97]
rownames(to_deconv) <- paste0('Sample_', 1:nrow(to_deconv))

##                           ##
##       DECONVOLUTION       ##
##                           ##
## Deconvolute with NMF
deconv_with_NMF_raw <- FALSE
deconv_with_package <- TRUE

if(deconv_with_NMF_raw){
  nmf_deconv_it <- list()
  rmse_vec <- c()
  for(i in 1:dim(to_deconv)[2]){
    cat('Rank:', i, '\n')
    nmf_deconv_it[[i]] <- NMF::nmf(to_deconv,
                                   rank = i,
                                   seed=134)
    rmse_vec <- c(rmse_vec,
                  sqrt(mean(to_deconv-fitted(nmf_deconv_it[[i]]))**2))
    
  }
  
  par(mfrow=c(1,1))
  plot(rmse_vec, type='l')
  
  par(mfrow=c(1,2))
  image(to_deconv)
  image(fitted(nmf_deconv_it[[10]]))
  
  par(mfrow=c(1,1))
  require(pheatmap)
  pheatmap(to_deconv-fitted(nmf_deconv_it[[10]]))

  ## what are the reconstructed signatures?
  ## here I am looking into the signatures when n=10, but from the RMSE
  ## it doesn't seem like there is much difference
  
  ## deconvoluted isgnatures:
  dim(nmf_deconv_it[[10]]@fit@H)
  ## true signatures:
  dim(do.call('rbind', sign))
  
  ## all signatures
  plot(nmf_deconv_it[[10]]@fit@H,
       do.call('rbind', sign), pch=19)  
  
  ##        IMPORTANT: THIS NEEDS TO HAVE THE CONSTRAINT THAT SUM_i=1!!
  ##        How do they do it?
  ##        https://www.cell.com/cell-reports/fulltext/S2211-1247(12)00433-0
  sum(nmf_deconv_it[[10]]@fit@H[1,])
  sum(sign[[1]])
  
  ## similarity of samples based on the contribution of each mutational signature
  contrib <- do.call('rbind',
                     lapply(res_sim_contribution_signatures, function(x) x$contribution))
  plot(hclust(dist(acomp(contrib))))
  
}


if(deconv_with_package){
  
  ###        USE SOME OTHER PAKCAGE FOR SIGNATURE EXTRACTION.
  ###        some examples of packages:
  ###        SomaticSignatures: it needs an vranges object and it finds
  ###                           the flanking bases with a reference
  ###                           genome (bad for simulation)
  ###       signeR: doesn't seem to work because of the version
  
  signatures <- signeR(M=to_deconv, Mheader = TRUE, Oppheader = TRUE)
  
  require(pheatmap)
  colSums(signatures$Phat) ## how is this not 1?? (constrain because they are prob)
  pheatmap(signatures$Phat, cluster_rows = FALSE, cluster_cols = FALSE)
  par(mfrow=c(1,2))
  pheatmap(to_deconv, cluster_rows = FALSE, cluster_cols = FALSE,
           show_rownames = FALSE, show_colnames = FALSE)
  pheatmap(t(signatures$Phat %*% signatures$Ehat), cluster_rows = FALSE, cluster_cols = FALSE)
  
  pheatmap0 <- function(x, ...) pheatmap(x, cluster_rows = FALSE, cluster_cols = FALSE, show_rownames = FALSE, show_colnames = FALSE, ...)
  
  signatures_normalised <- sweep(signatures$Phat, 2, colSums(signatures$Phat), '/')
  
  pheatmap0(t(signatures_normalised))
  pheatmap0(do.call('rbind', sign))
  
  cos.sim <- function(A, B) {
    A = t(signatures_normalised)[A,]
    B = do.call('rbind', sign)[B,-97]
    return( sum(A*B)/sqrt(sum(A^2)*sum(B^2)) )
  }   
  
  pheatmap0(outer(1:nrow(t(signatures_normalised)),
                  1:(nrow(do.call('rbind', sign))),
                  Vectorize(cos.sim)),
            main = 'Cosine similarity between true (simulated) \nand extracted signatures')

}

###        below: to re-run
# ## sign #1
# plot(nmf_deconv_it[[10]]@fit@H[1,],
#      do.call('rbind', list(sign[[1]])), pch=19,
#      xlab='Reconstructed', ylab='True')

#        AIMS        #
#     1. Speeed up



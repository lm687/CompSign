#' Create categories of mutations (change + flanking bases)
#' given an alphabet
create_catMut <- function(basic_cat = c('A', 'C', 'G', 'T')){
  cat('A bit of a weird notation, which I should change. "AGG>G" means that there has been the change GAG>GGG.\n')
  require(combinat)
  require(arrangements)

  cat_mut <- arrangements::permutations(x = basic_cat,
                          k = 3, replace = TRUE)
  cat_mut <- cat_mut[1:(nrow(cat_mut)/2),]
  cat_mut <- apply(cat_mut, 1, function(x){
    tmp <- c()
    for(i in basic_cat[!(basic_cat == cat_mut[2])]){
      tmp <- rbind(tmp, c(x, i))
    }
    apply(tmp, 1, function(x) paste0(paste0(x[1:(length(basic_cat)-1)],
                                            collapse = ''),
                                     '>', x[length(basic_cat)]))
  })
  cat_mut <- sort(unlist(cat_mut))
  cat_mut <- c(cat_mut, 'None')
  cat_mut
}

#' Create exposures with a hidden markov model, where
#' the hidden states are the state of exposure (0 or 1)
#' (active or inactive) and the emitted states are the nucleotides
createExposure <- function(transition_matrix, emission_matrix,
                           length_out, init_prob){
  idx <- c(1,2)
  names(idx) <- c(0,1)
  .init_idx <- sample(1:length(init_prob), size = 1, prob = init_prob)
  .init <- names(idx)[.init_idx]
  .chain_idx <- rep(NA, length_out); .chain <-  rep(NA, length_out)
  .chain_idx[1] <- .init_idx
  .chain[1] <- names(idx)[.chain_idx[1]]
  .emitted <- sample(colnames(emission_matrix), size = 1,
                     prob = emission_matrix[.init_idx,])
  for(it in 2:length_out){
    .chain_idx[it] <- sample(1:nrow(transition_matrix), 1, FALSE,
                            transition_matrix[.chain_idx[it-1],])
    .chain[it] <- names(idx)[.chain_idx[it]]
    .emitted[it] <- sample(colnames(emission_matrix), size = 1,
                          prob = emission_matrix[.chain_idx[it],])
  }
  return(list(hiddenchain=.chain, emitted=.emitted, sign=create_emission_matrix(length(cat_mut))[2,]))
}

#' Random wlk (sort of; no negative values)
#' Alpha=0 returns the same value as input
randomwalk_next <- function(val, alpha=1){
  proposal <- val + alpha*(runif(1, -1, 1))
  return(max(0, proposal))
}

#' Create a markov chain which represents the exposures, and with which
#' we simulate mutations which come from a single mutational signature
#' This mutational signture can be created at random or fed in
createExposureContinuous <- function(transition_matrix,
                                     signature=NULL,
                                     emission_kernel,
                                     random_signature=FALSE,
                                     length_out,
                                     init_val,
                                     alpha=1){

  require(MCMCpack)

  ##    not sure if emission kernel is the right terminology
  ##    here using poisson. change to get(KRNL),
  ##    where KRNL can be e.g. rpois(1, hidden_val)

  ## random_signature: should the signature definition be randomly constructed?
  if(random_signature){
    signature <- MCMCpack::rdirichlet(n = length(cat_mut),
                                      alpha = rep(1, length(cat_mut)))
  }

  if(!random_signature & is.null(signature)) stop('You need to specify a signature or set random_signature=TRUE')

  .chain <- rep(NA, length_out) ## exposures
  .emitted <- replicate(length_out, list())
  .chain[1] <- randomwalk_next(init_val, alpha)
  .emitted[[1]] <- sample(x = 1:length(signature), size = rpois(1, .chain[1]), replace = TRUE, prob = signature)

  for(i in 2:length_out){
    .chain[i] <- randomwalk_next(.chain[i-1], alpha)
    .emitted[[i]] <- sample(x = 1:length(signature),
                            size = rpois(1, .chain[i]),
                            replace = TRUE,
                            prob = signature)
  }
  return(list(hiddenchain=.chain, emitted=.emitted, sign=sign))
}


#' Flatten an object returned from createExposure or createExposureContinuous
flatten_emitted_fun <- function(sim_chain_cont_object, names=FALSE){
  x <- length(sim_chain_cont_object$emitted)
  if(names){
    ## the input is a string of mutations, e.g. CTG>T
    flat_emitted_tmp <- table(factor(unlist(lapply(1:x, function(y) sim_chain_cont_object$emitted[[y]])),
                                     levels=names(sim_chain_cont_object$sign)))
  }else{
    flat_emitted_tmp <- table(factor(unlist(lapply(1:x, function(y) sim_chain_cont_object$emitted[[y]])),
                                     levels=1:(length(sim_chain_cont_object$sign))))
    }
  flat_emitted_tmp
#  flat_emitted_tmp <- do.call('rbind', flat_emitted_tmp)
}

#' Wrapper number 1
wraper_create_and_flatten <- function(...){
  tmp <- createExposureContinuous(...)
  flatten_emitted_fun(tmp)
}

wraper_create_and_flatten_discrete <- function(...){
  tmp <- createExposure(...)
  #tmp
  #tmp[,ncol(tmp)]
  flatten_emitted_fun(tmp, TRUE)
}


create_emission_matrix <- function(cat_mut){
  Ncat <- length(cat_mut)
  require(MCMCpack)
  emisssion_matrix_example <- MCMCpack::rdirichlet(n = 1, alpha = rep(1,Ncat))
  emisssion_matrix_example <- matrix(c(rep(0, Ncat-1), 1,
                                       emisssion_matrix_example),
                                     byrow = TRUE,
                                     ncol = Ncat)
  colnames(emisssion_matrix_example) <- cat_mut
  emission_matrix <- emisssion_matrix_example
  emission_matrix
}

giveListStatistics <- function(list_pairs_new, outerCS, matrix_of_coef){
  list(sum_cosine_similarities = sum(apply(list_pairs_new, 1, function(vec) outerCS[vec[1],vec[2]])),
     max_cosine_similarities = max(outerCS),
     cosine_similarities = outerCS,
     cosine_similarities_pairs = apply(list_pairs_new, 1, function(vec) outerCS[vec[1],vec[2]]),
     matrix_exposures=matrix_of_coef,
     matrix_exposures_original_colMeans=colMeans(matrix_of_coef[,list_pairs_new[,1]]),
     matrix_exposures_original_colSums=colSums(matrix_of_coef[,list_pairs_new[,1]]),
     matrix_exposures_original_min=apply(matrix_of_coef[,list_pairs_new[,1]], 2, min),
     matrix_exposures_original_max=apply(matrix_of_coef[,list_pairs_new[,1]], 2, max))
}

#' ~Cosine similarity
cosineSimilarity <- function(A, B) {
  return( sum(A*B)/sqrt(sum(A^2)*sum(B^2)) )
}

#' 1. Create mutational signatures
#' 2. Create samples, with their exposures
#' 3. Deconvolute the matrix. The rank is given and is the same as the number of mutational signatures I used to create the original matrix. Read the note below.
#' 4. Find pairs of signatures for comparison
#' 5. Find some statistic of 'goodness of fit' between all paired signatures
#'
#' To add:
#' - NNLS: compare exposures (ongoing)
recover_signatures <- function(nsignatures = 10, nsamples= 20,
                               old_version_sim_mut=FALSE, verbose = FALSE,
                               statistics_type = 'definition_sigs'){
  require(here)
  source(here::here("code/functions/WrapperlikeFunctions.R"))
  source(here::here("code/functions/SimFunctions.R"))

  if(verbose) cat('Starting\n')

  ## 0. create the categories of mutation
  cat_mut <- create_catMut()

  if(verbose) cat('Creating the signatures\n')
  ## 1. Creating the signatures
  signature_i <- MCMCpack::rdirichlet(nsignatures, rep(1, length(cat_mut)))
  if(old_version_sim_mut) signature_i <- replicate(nsignatures, create_emission_matrix(cat_mut), simplify = FALSE)

  ## 2. Create the samples, with exposures for each signature
  ## for each of the samples there is a coefficient corresponding to each of the signatures
  if(verbose) cat('Creating samples\n')
  matrix_of_coef <- MCMCpack::rdirichlet(nsamples, alpha = rep(1, nsignatures))

  if(old_version_sim_mut){
    ## this is very slow and stupid
    persample <- lapply(1:nsamples, function(sam){
      if(verbose) cat('+')
      tmp_various_sign <- lapply(1:nsignatures, function(i){
        wraper_create_and_flatten_discrete(transition_matrix = matrix(c(1, 0, 0, 1),
                                                                      byrow=TRUE, ncol=2),
                                           length_out = 1e4,
                                           init_prob=c(0, 1),
                                           emission_matrix=signature_i[[i]]*matrix_of_coef[sam,i])})
      tmp_various_sign_reduced <- Reduce('+', tmp_various_sign)
      tmp_various_sign_reduced
    })
    to_deconv <- do.call('rbind', persample) ##    I don't even think this is correct

  }else{
    tmp_various_sign_reduced <- round(1e4/nsamples*(matrix_of_coef %*% signature_i))
    to_deconv <- tmp_various_sign_reduced
  }

  ## 3. Deconvolute this matrix
  if(verbose) cat('Deconvoluting\n')

  nmf_deconv <- NMF::nmf(to_deconv,
                         rank = nsignatures,
                         seed=134)

  ## 4. Compare the simulated and the derived signatures; see how well we can recover them

  ## to add: NNLS
  ## i.e. for the relevant signature, find the coefficient when fitting it to the original matrix and
  ## ... think about this
  ## not sure if this is the best approach:
  if(statistics_type == 'both'){
    statistics_type0 <- 'both'
    statistics_type <- c('definition_sigs', 'exposures')
  }else{
    statistics_type0 <- statistics_type
  }
  if('definition_sigs' %in% statistics_type){
    if(verbose) cat('Assessing the recovery of signatures\n')
    norm_H <- sweep(nmf_deconv@fit@H, 1, rowSums(nmf_deconv@fit@H), '/')
    if(old_version_sim_mut){
      outerCS_H <- outerCosineSimilarity(norm_H, t(sapply(signature_i, function(x) x[2,])))
    }else{
      outerCS_H <- outerCosineSimilarity(norm_H, signature_i)
    }
    list_pairs_H <- pair_signatures(outerCS_H, nsignatures)
    list_pairs_new_H <- sequential_to_original(list_pairs_H)
  }
  if('exposures' %in% statistics_type){
    if(verbose) cat('Assessing the recovery of signatures: comparison of exposures\n')
    norm_W <- sweep(nmf_deconv@fit@W, 1, rowSums(nmf_deconv@fit@W), '/')
    outerCS_W <- outerCosineSimilarity(t(norm_W), t(matrix_of_coef))
    list_pairs_W <- pair_signatures(outerCS_W, nsignatures)
    list_pairs_new_W <- sequential_to_original(list_pairs_W)
  }
  if(!any(c('definition_sigs', 'definition_sigs') %in% statistics_type)){
    stop('Must set <statistics_type> to "definition_sigs" or "exposures" or "both"')
  }
  if(statistics_type0 == 'definition_sigs'){
    statistics <- giveListStatistics(list_pairs_new_H, outerCS_H, matrix_of_coef)

  }else if(statistics_type0 == 'exposures'){
    statistics <- giveListStatistics(list_pairs_new_W, outerCS_W, matrix_of_coef)

  }else if(statistics_type0 == 'both'){
    statistics <- list(giveListStatistics(list_pairs_new_H, outerCS_H, matrix_of_coef),
                       giveListStatistics(list_pairs_new_W, outerCS_W, matrix_of_coef))
  }else{
    stop('Check <statistics_type> argument')
  }

  return(statistics)
}


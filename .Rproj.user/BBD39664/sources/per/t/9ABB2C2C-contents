######################################
## Test for equality of populations ##
######################################
## 0. visualising differences in groups with barplots
## 1. test for equality of populations
## 1.1 validity of assumptions of model
## 1.2 correction of p-values
## 1.3 results/conclusions

#' Compositional::comp.test
#' Compositional::hotel2T2

#' Are the compositions of two groups different?
#'
#' Consider the following hypothesis:
#' 1. there is no difference between both groups;
#' 2. the covariance structure is the same, but centres are different;
#' 3. the centres are the same, but the covariance structure is different;
#' 4. the groups differ in their centres and in their covariance structure.

rm(list = ls())
setwd(dirname(rstudioapi::getSourceEditorContext()$path))

library(compositions)
library(CompSign)
library(Hotelling)
library(reshape2)
library(ggplot2)

# The geometric mean barplot (Figure 1) is an option for describing differences
# between groups. Given a CoDa set, for each group, the logratio between the whole
# geometric mean and the geometric mean of the group is calculated
# NOTE!:       there will have to be pseudocounts here      
# If there are two categories and the barplots renot symmetrical, it's because
# of the size of the groups! should it be weighted?

geom_mean <- function(x) exp(mean(log(x)))
for(i in list.files("../../../../../CompSign/data", pattern = "*rda", full.names = TRUE)){load(i)}

clean_dataset <- function(metadata_name, expected_categories, exposures){
  group_vector <- metadata(CNA_12K_TCGA)[,metadata_name]
  group_vector_bool <- group_vector %in% expected_categories
  group_vector_bool_clean <- group_vector[group_vector_bool]
  exposures_clean <- exposures[group_vector_bool,]
  list(exposures_clean=exposures_clean, group_vector_bool_clean=group_vector_bool_clean)
}

give_LR_geom_means <- function(metadata_name, expected_categories, exposures){
  clean_dataset_res <- clean_dataset(metadata_name, expected_categories, exposures)
  exposures_clean <- clean_dataset_res[['exposures_clean']]
  group_vector_bool_clean <- clean_dataset_res[['group_vector_bool_clean']]

  barplot_geom_means <- lapply(1:ncol(exposures), function(x){
    total_geom_mean <- geom_mean(exposures_clean[,x])
    tmp_logR <- do.call('cbind.data.frame', lapply(expected_categories, function(cat)
      log(geom_mean(exposures_clean[group_vector_bool_clean == cat,x])/total_geom_mean)))
    names(tmp_logR) <- expected_categories
    tmp_logR
  })
  names(barplot_geom_means) <- paste0('S ', 1:ncol(exposures))
  melt(barplot_geom_means)
}

barplot_geom_means <- give_LR_geom_means(metadata_name = 'gender',
                                         expected_categories = c('male', 'female'),
                                         exposures = addPseudoCounts(count_matrix(CNA_12K_TCGA), 1e-7))
ggplot(barplot_geom_means, aes(x=L1,y=value,fill=variable))+
  geom_bar(position='dodge', stat = 'identity')+
  facet_wrap(.~L1, scales = 'free_x', nrow=1)+
  labs(x='', y='Log ratio of group geom mean\n to total geom mean')+
  ggtitle('Log ratio of geometric mean of group and geometric mean of whole population\n Pseudocount of 1e-7 added')
ggsave("../../../../results/real/CNA12kTCGA/test_equality/geometric_mean_gender.png", width = 10, height = 3)


plot_several <- function(list_names_and_categories){
  require(gridExtra)
  plots_list <- list()
  for(it_metadata in 1:length(list_names_and_categories)){
    tmp_df <- give_LR_geom_means(metadata_name = list_names_and_categories[[it_metadata]][[1]],
                                 expected_categories = list_names_and_categories[[it_metadata]][[2]],
                                 exposures = addPseudoCounts(count_matrix(CNA_12K_TCGA), 1e-7))
    plots_list[[it_metadata]] <- ggplot(tmp_df,
           aes(x=L1,y=value,fill=variable))+
      geom_bar(width = 0.8, position = position_dodge(width = 0.2), stat = 'identity')+
      #facet_wrap(.~L1, scales = 'free_x', nrow=1)+
      labs(x='', y='Log ratio of group geom mean\n to total geom mean')+
      ggtitle(paste0('Log ratio of geometric mean of group and geometric mean of whole population\n',
                     list_names_and_categories[[it_metadata]][[1]],
                     '\nPseudocount of 1e-7 added'))
  }
  names(plots_list) <- paste0('Plot', 1:length(plots_list))
  do.call("grid.arrange", c(plots_list, ncol=min(length(plots_list),2)))
}

pdf("../../../../results/real/CNA12kTCGA/test_equality/geometric_mean_project.pdf", width = 20, height = 6)
plot_several(list(list('project_id', unique(metadata(CNA_12K_TCGA)[,'project_id']))))
dev.off()


my_list_names_and_categories <- list(list('vital_status', c('alive', 'dead')),
                                     list('gender', c('female', 'male')),
                                     list('ethnicity', c('not hispanic or latino', 'hispanic or latino')),
                                     list('race', unique(metadata(CNA_12K_TCGA)[,'race'])[-7]),
                                     list('tumor_stage', unique(metadata(CNA_12K_TCGA)[,'tumor_stage'])),
                                     list('alcohol_history', c('yes', 'no'))
                                     )
pdf("../../../../results/real/CNA12kTCGA/test_equality/geometric_mean_many.pdf", width = 15, height = 15)
plots_2 <- plot_several(my_list_names_and_categories)
dev.off()

pdf("../../../../results/real/CNA12kTCGA/test_equality/geometric_mean_ethnicity.pdf", width = 20, height = 6)
plot_several(list(list('ethnicity', c('not hispanic or latino', 'hispanic or latino'))))
dev.off()


colnames(metadata(CNA_12K_TCGA))
unique(metadata(CNA_12K_TCGA)[,'tumor_grade'])

############
## manova ##
############
exposures <- count_matrix(CNA_12K_TCGA)
#' ilr(  X_k) =  ilr( μ_k)+ ilr(ε_k)

#' manova assumes that ilr for error term is normally distributed (i.e. error term ε is
#' normal and homocedastic
#' testing for this: goodness-of-fit test suggested in Aitchison (1986) for compositional data.
#' This test is based on the idea that, under the assumption of normality,
#' the radii (or squared Mahalanobis distances) of the residuals are approximately
#' distributed as a chi-squared distribution

#' We can use some empirical distribution function statistics, for instance
#' Anderson-Darling or Cramer-von Mises, to test significant departures from
#' the chi-squared distribution. Importantly, because Mahalanobis distances
#' are invariant under change of basis, this normality test can be calculated
#' using any ilr coordinates obtained with an SBP.
meta <- metadata(CNA_12K_TCGA)[,'gender']
hist(MahalanobisDist(ilr(exposures[meta %in% c('female', 'male'),])), breaks=100)

ilr_subset <- ilr(exposures[meta %in% c('female', 'male'),])
## ilr  is definitely not normal, due to zeroes, but maybe the error is...?
par(mfrow=c(2,3))
for(i in 1:6){
  hist(ilr_subset[,i], breaks=100)
}

give_hotelling <- function(metadata_type, expected_categories, exposures, subset_ilr=NULL){
  if(is.null(subset_ilr)){subset_ilr <- 1:ncol(exposures)}
  if(length(expected_categories)>2){stop('Only two expected categories!')}
  meta <- metadata(CNA_12K_TCGA)[,metadata_type]
  ilr_subset <- ilr(exposures[meta %in% expected_categories, subset_ilr])
  a <- hotelling.test(ilr_subset[meta[meta  %in% expected_categories] == expected_categories[1],],
                      ilr_subset[meta[meta  %in% expected_categories] == expected_categories[2],])
  a
}


#' if testing for many groups that might potentially be cause of difference:
#' In this procedure, there is a general recommendation to avoid an artificial
#' increase of the Type I Error rate: to adjust the alpha level of each test
#' by making some kind of correction, e.g. Bonferroni or FDR

give_hotelling('gender', c('female', 'male'), exposures)
give_hotelling('alcohol_history', c('yes', 'no'), exposures)
give_hotelling('vital_status', c('dead', 'alive'), exposures)

#' Leave exposures out
#' Following the previous approach, these univariate comparisons will be done
#' through D−1 simultaneous t-tests. Again, in this case it is accordingly necessary
#' to adjust the critical level or use a more complex technique
#'
give_hotelling('gender', c('female', 'male'), acomp(exposures[,-6]))
give_hotelling('gender', c('female', 'male'), exposures, c(1:5,7)) ## it's the same
give_hotelling('gender', c('female', 'male'), acomp(exposures[,-c(3,6,1,2)]))

##' Procedure for making bootstrap percentile confidence intervals
##' for log-ratio differences between groups and interpreting them
##' (as shown in physical activity paper)
##'

givelogR <- function(exposures_clean, expected_categories, group_vector_bool_clean){
  ##' i. The geometric mean of each behavior (%) in both groups are calculated.
  tmp_nest1 <- lapply(expected_categories, function(cat){
    tmp_nest2 <- lapply(1:ncol(exposures_clean), function(x){
      geom_mean(exposures_clean[group_vector_bool_clean == cat,x])})
    names(tmp_nest2) <- paste0('S', 1:7)
    tmp_nest2
  })
  names(tmp_nest1) <- expected_categories
  ##' ii. The log-ratio of geometric means of both groups (ie., men/women or younger/older)
  ##' is computed. For sex, the numerator in the log-ratio is men and denominator is women,
  ##' while for age groups the numerator is younger and the denominator is older workers.

  log(unlist(tmp_nest1[[1]])/unlist(tmp_nest1[[2]]))
}

give_geom_means_per_group <- function(metadata_name, expected_categories, exposures){
  clean_dataset_res <- clean_dataset(metadata_name, expected_categories, exposures)
  exposures_clean <- clean_dataset_res[['exposures_clean']]
  group_vector_bool_clean <- clean_dataset_res[['group_vector_bool_clean']]

  givelogR(exposures_clean, expected_categories, group_vector_bool_clean)
}

exposures_with_pc <- addPseudoCounts(exposures, 1e-7)
geom_means_per_group_gender <- give_geom_means_per_group('gender', c('female', 'male'), exposures_with_pc)

##' iii. First, 1000 virtual data sets are drawn with replacement from the source population and
##' of the same size. For each resample, the log-ratio of the geometric mean explained in step ii
##' is calculated. The resulting distribution of 1000 log-ratios are averaged to calculate
##' bootstrapped mean, and the 2.5th and 97.5th percentiles were selected as upper and lower
##' limits of 95%confidence intervals of the bootstrapped mean.

bootstrap_plot <- function(metadata_type, metadata, expected_categories, exposures_with_pc){
  if(length(expected_categories) > 2){stop('More than 2 groups have not been implemented yet')}
  ndatasets <- 1000
  table_metadata <- table(metadata[,metadata_type])
  random_dataset_means <- table_metadata

  replicate_log <- replicate(n = ndatasets, simplify = FALSE,
            expr = givelogR(exposures_clean = exposures_with_pc[c(sample(1:nrow(exposures_with_pc),
                                                   size = table_metadata[expected_categories[1]], replace = TRUE),
                                            sample(1:nrow(exposures_with_pc),
                                                   size = table_metadata[expected_categories[2]], replace = TRUE)),],
           expected_categories =  expected_categories,
           group_vector_bool_clean = c(rep(expected_categories[1], table_metadata[expected_categories[1]]),
                                       rep(expected_categories[2], table_metadata[expected_categories[2]]))))
  replicate_log <- do.call('rbind', replicate_log)

  bootstrap_mean <- colMeans(replicate_log)

  percentiles_metadata <- apply(replicate_log, 2, quantile, probs = c(0.025, 0.975))
  percentiles_metadata <- rbind.data.frame(percentiles_metadata, bootstrap_mean=bootstrap_mean)

  ggplot(melt(replicate_log), aes(x=Var2,y=value))+
    geom_violin()+
    geom_point(data=cbind.data.frame(logR=geom_means_per_group_gender, names=names(geom_means_per_group_gender)),
               aes(x=names,y=logR), col='blue')+
    geom_point(data=melt(data.frame(what=rownames(percentiles_metadata), percentiles_metadata)),
               aes(x=variable, y=value), col='red')+
    ggtitle(paste0('Bootstrap-based confidence intervals\n', toupper(metadata_type)))
}

bootstrap_plot(metadata_type = 'gender', metadata = metadata(CNA_12K_TCGA),
               expected_categories = c('female', 'male'), exposures_with_pc = exposures_with_pc)
ggsave("../../../../results/real/CNA12kTCGA/test_equality/bootstrap_geometricmean_gender.png", width = 10, height = 3)

bootstrap_plot(metadata_type = 'vital_status', metadata = metadata(CNA_12K_TCGA),
               expected_categories = c('alive', 'dead'), exposures_with_pc = exposures_with_pc)
ggsave("../../../../results/real/CNA12kTCGA/test_equality/bootstrap_geometricmean_vital_status.png", width = 10, height = 3)

bootstrap_plot(metadata_type = 'alcohol_history', metadata = metadata(CNA_12K_TCGA),
               expected_categories = c('yes', 'no'), exposures_with_pc = exposures_with_pc)
ggsave("../../../../results/real/CNA12kTCGA/test_equality/bootstrap_geometricmean_alcohol_history.png", width = 10, height = 3)


###################
####### END #######
###################

### previous; to add

##
data("Breast560")
load("../../../../../CompSign/data/Breast560.rda")
if(!all(round(rowSums(count_matrix(Breast560)), digits = 4) == 1)){stop('Old version of Breast560! Stopping')}

res_compostional_560 <- comp.test(x = count_matrix(Breast560),
                                  ina = as.numeric(as.factor(metadata(Breast560)$final.ER)),
                                  test = "james", R = 0)

comp.test(x = count_matrix(Breast560),
          ina = as.numeric(as.factor(metadata(Breast560)$final.PR)),
          test = "james", R = 0)


## compute mean, variance
## is the mean the geometric mean?
plot(rbind(mean(acomp(count_matrix(Breast560))),
           mean(acomp(count_matrix(Breast560)[as.numeric(as.factor(metadata(Breast560)[,'final.ER'])) == 1,])),
           mean(acomp(count_matrix(Breast560)[as.numeric(as.factor(metadata(Breast560)[,'final.ER'])) == 1,]))), type='l')

############################################
############# as done before ###############
#################  A0  #####################
print_equality_test <- function(ilr_transformation, clinical, metadata_tmp, exposures_tmp){
  require(Hotelling)
  two_pops <- split_into_groups(df = ilr_transformation, classes = metadata_tmp[,clinical])
  tmp_clin <- as.numeric(as.factor(metadata_tmp[,clinical]))
  list(  Compare_mean=comp.test(x = ilr_transformation[!is.na(tmp_clin),],
                                ina = tmp_clin[!is.na(tmp_clin)],
                                test = "james", R = 0),
         Hotelling=ilr2clr(hotel2T2(two_pops[[1]], two_pops[[2]], a = 0.05, R = 999, graph = TRUE)$mesoi,
                           x = exposures_tmp))
}

## are the two populations the same?
split_into_groups <- function(df, classes){
  df <- df[!is.na(classes),]
  classes <- classes[!is.na(classes)]
  idx <- classes == classes[1]
  idx_comp <- (1:length(classes))[! ( (1:length(classes)) %in%idx)]
  list(df[idx,], df[idx_comp,])
}
############################################

#' Results for gender and alcohol history.
#' Gender is statisitically different, but why? need to check.
#' Alcohol history is not different.

par(mfrow=c(1,2))
print_equality_test(ilr(exposures), 'gender',
                    metadata(CNA_12K_TCGA),
                    count_matrix(CNA_12K_TCGA))
print_equality_test(ilr(exposures), 'alcohol_history',
                    metadata(CNA_12K_TCGA),
                    count_matrix(CNA_12K_TCGA))
print_equality_test(ilr(exposures), 'vital_status',
                    metadata(CNA_12K_TCGA),
                    count_matrix(CNA_12K_TCGA)) ##??



compare_populations

variables_analysed <- c(variables_analysed, 'gender', 'alcohol_history')
# variables_remaining()

compare_populations(exposures_tmp[metadata_tmp$gender %in% c('male', 'female'),],
                    response = metadata_tmp$gender[metadata_tmp$gender %in% c('male', 'female')])


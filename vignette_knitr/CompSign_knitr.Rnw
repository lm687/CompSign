\documentclass{article}

\usepackage{hyperref}
\usepackage[backend=bibtex, maxnames=10]{biblatex}
\usepackage{xargs}
\usepackage{xcolor}
\usepackage{soul}

\title{Package \textbf{CompSign}}
\author{Lena Morrill}
\date{October 2017}

\bibliography{../../CDA_in_Cancer/text/progress_text/bibliography.bib}

\newcommandx{\myemph}[2][1=]{\begin{center}\hl{#1}\end{center}}

\begin{document}

\maketitle

\begin{center}
\textbf{Important note: }{\verb|V=V| needs to be changed to \verb|V=gsi.buildilrBase(V)| everywhere.}
\end{center}

\textbf{CompSign} is a toolkit for the analysis of mutational signatures with an emphasis on the compositional analysis of exposures. An overview of the compositional nature of the exposures to mutational signatures, which has been often overlooked, is found elsewhere\footnote{cite myself}.

\tableofcontents

% The reference manual can be found \href{https://github.com/lm687/CompSign/blob/master/CompSign.pdf}{here}.

% \tableofcontents

<<include=FALSE>>=
knitr::opts_chunk$set(cache = TRUE)
@

\section{Installation}
\texttt{CompSign} can be installed as usual from github:

<<include=TRUE, eval=FALSE>>=
library(devtools)
devtools::install_github("lm687/CompSign")
@

<<eval=TRUE, include=TRUE, message=FALSE, warning=FALSE>>=
library(CompSign)
library(compositions)
library(MCMCpack)      ## for sampling from Dirichlet
library(ggplot2)
library(gridExtra)
library(ComplexHeatmap)
library(circlize)
@

\clearpage
\section{Datasets}
<<>>=
## if the folder data/ is not in github
for(i in list.files("../data/", pattern = "*rda", full.names = TRUE)){load(i)}
@

The package contains several datasets of exposures to mutational signatures and metadata of the corresponding samples. These datasets are:
\begin{itemize}
\item SNV signatures
\begin{itemize}
\item Data for 560 breast cancer patients

<<>>=
# data("Breast560")
metadataBreast560 <- metadata(Breast560)
exposuresBreast560 <- count_matrix(Breast560)
dim(metadataBreast560); dim(exposuresBreast560)
@

\item Pan-cancer from EMu\cite{fischer2013emu} (cite dataset)
\end{itemize}
\item Copy Number signatures
\begin{itemize}
\item Ovarian cancer-derived signatures, as described in \cite{macintyre2018copy}. It contains data for 12k TCGA samples.

<<>>=
#data("CNA_12K_TCGA")
metadataCNA_12K_TCGA <- metadata(CNA_12K_TCGA)
exposuresCNA_12K_TCGA <- count_matrix(CNA_12K_TCGA)
@

\item Pan-cancer copy number signatures
\end{itemize}
\item Synthetic data
<<>>=
dim(metadata(two_normal_pops))
dim(count_matrix(two_normal_pops))
#data(two_normal_pops)
@
\end{itemize}

Data can be visualised as follows \hl{add this to the functions of the package}

<<message=FALSE, warning=FALSE, fig.height=2>>=
source("../../CDA_in_Cancer/code/functions/meretricious/pretty_plots/prettySignatures.R", print.eval = TRUE)
createBarplot(count_matrix(Breast560), remove_labels = TRUE,
              order = names(sort(count_matrix(Breast560)[,1])))
@


\section{Create a \texttt{CompSign} object}
This is a minimal example for transforming a matrix into a \emph{sign} object
<<>>=
basic_matrix <- matrix(runif(12), nrow = 4)
colnames(basic_matrix) <- paste0('s', 1:3)
rownames(basic_matrix) <- paste0('Sample ', 1:4)
basic_sign <- to_sign(basic_matrix)
basic_sign
@

A \emph{sign} object can be summarised as follows:

\hl{add\_together\_matrix?? what is this?}

<<>>=
results_sumarise <- summarise(add_together_matrix(basic_sign))
results_sumarise
@

\clearpage
\section{Battery of tests}
This section takes largely from Aitchison's pioneering work\cite{aitchison1982statistical} and its succession\cite{pawlowsky2015modeling}.

\subsection{Test for normality}
<<>>=
par(mfrow=c(1,2))
# qqnorm.acomp(acomp(two_normal_pops@count_matrix), pch=19, cex=0.2)
qqnorm.acomp(acomp(two_normal_pops@count_matrix[1:1000,]), pch=19, cex=0.2)
@

\subsection{Test for equality}
Test for equality of means.
<<warning=FALSE, message=FALSE>>=
compare_populations(predictors = count_matrix(Breast560),
                    response = as.numeric(as.factor(metadata(Breast560)$final.ER)))
@

<<eval=FALSE, include=FALSE>>=
##' Older version (?)
# comp.test(x = count_matrix(Breast560),
#                               ina = as.numeric(as.factor(metadata(Breast560)$final.ER)),
#                               test = "james", R = 0)
@



\section{Clustering of samples}
Samples can simply be clustered by the cosine similarity of their exposures, as done in Ren et al.

<<cache=TRUE>>=
res_outerCosineSimilaritySNV <- outerCosineSimilarity(exposuresBreast560, exposuresBreast560, verbose=FALSE)
ComplexHeatmap::Heatmap(res_outerCosineSimilaritySNV)

# res_outerCosineSimilarityCNA <- outerCosineSimilarity(exposuresCNA_12K_TCGA[metadataCNA_12K_TCGA$project_id %in% c("TCGA-BRCA", "TCGA-SKCM"),],
#                                                       exposuresCNA_12K_TCGA[metadataCNA_12K_TCGA$project_id %in% c("TCGA-BRCA", "TCGA-SKCM"),],
#                                                       verbose=FALSE)
# ComplexHeatmap::Heatmap(res_outerCosineSimilarityCNA)
@

\clearpage
\section{Symmetric balances for correlation between signatures}
Pearson pointed out (\cite{pearson1897mathematical}) that spurious correlations appear when closed, compositional, data, are analysed. Therefore normal correlation coefficients can be ruled out of our analysis.

I implement a correlation coefficient based on symmetric balances as introduced in \cite{kynvclova2017correlation}.

\begin{center}
\hl{Code not shown because it's quite messy and under development, but check function \texttt{plotcomputeRho()}}
\end{center}

<<symmetric_balances_cor, echo=FALSE, fig.height=8>>=

for(i in list.files("../../CompSign/data", pattern = "*rda", full.names = TRUE)){load(i)}
dataset <- list(CNA_12K_TCGA=CNA_12K_TCGA,
                CNA_12K_TCGA_v2_QP=CNA_12K_TCGA_v2_QP,
                CNA_12K_TCGA_v2_YAPSA=CNA_12K_TCGA_v2_YAPSA)
version_dataset <- 'CNA_12K_TCGA_v2_QP'
exposures_tmp <- count_matrix(dataset[[version_dataset]])

grid.newpage()
pushViewport(viewport(layout = grid.layout(nr = 3, nc = 2)))
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 1))
draw(plotcomputeRho(x = exposures_tmp, pseudocount =  1e-7,
               names_sigs = paste0('s', 1:7),
               column_title='CNA TCGA QP dataset - rho'), ## why is it all so extremely high?
     newpage = FALSE)
upViewport()

pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 2))
draw(plotcomputeclrcor(x = exposures_tmp, pseudocount =  1e-7,
               names_sigs = paste0('s', 1:7),
               column_title='CNA TCGA QP dataset - cor clr'),
     newpage = FALSE)
upViewport()

pushViewport(viewport(layout.pos.row = 2, layout.pos.col = 1))
Ncomp <- 5
Nsamps <- 100
X <- MCMCpack::rdirichlet(Nsamps, rep(1,Ncomp))
draw(plotcomputeRho(X, names_sigs = paste0('S', 1:Ncomp),
      column_title='CNA TCGA QP dataset - rho'), newpage = FALSE)
upViewport()
pushViewport(viewport(layout.pos.row = 2, layout.pos.col = 2))
draw(plotcomputeclrcor(X, names_sigs = paste0('S', 1:Ncomp),
      column_title='CNA TCGA QP dataset - cor clr'), newpage = FALSE)
upViewport()

pushViewport(viewport(layout.pos.row = 3, layout.pos.col = 1))
draw(plotcomputeRho(count_matrix(Breast560), pseudocount = 1e-7,
               names_sigs = colnames(count_matrix(Breast560)),
               column_title = '560 Breast cancers (Nik-Zainal) - rho'), newpage = FALSE)
upViewport()
pushViewport(viewport(layout.pos.row = 3, layout.pos.col = 2))
draw(plotcomputeclrcor(count_matrix(Breast560), pseudocount = 1e-7,
                  names_sigs = colnames(count_matrix(Breast560)),
                  column_title = '560 Breast cancers (Nik-Zainal) - cor clr'), newpage = FALSE)
upViewport()

@
\clearpage

\section{Optimal selection of partition}

<<fig.height=4, fig.width=6>>=
set.seed(1234)

## simulated data
Nsig <- 5; Nsamp <- 100
props <- MCMCpack::rdirichlet(Nsamp, c(rep(1,Nsig)))
colnames(props) <- paste0('Sig', 1:Nsig)
rownames(props) <- paste0('Sam ', 1:Nsamp)
## increase exposure to signature 1 in the first
## Nsamp/2, and re-normalise (two groups)
props[1:floor(Nsamp/2), 1] <- props[1:floor(Nsamp/2), 1] + 1.5
props <- sweep(props, 1, rowSums(props), '/')
createBarplot(props, remove_labels = TRUE)

## corresponds to partitioning as follows:
##(s1, s2, s3) vs (s4, s5)
V <- c(1, 1, 1, -1, -1)
# plot(density(ilr(props, V = V)))
boxplot(ilr(props, V = V)[1:floor(Nsamp/2)],
        ilr(props, V = V)[(floor(Nsamp/2)+1):Nsamp], main = 'Comparison of ilr of (s1, s2, s3) vs (s4, s5) for the two groups')


t.test(ilr(props, V = V)[1:floor(Nsamp/2)],
       ilr(props, V = V)[(floor(Nsamp/2)+1):Nsamp])$p.value


it_partitions <- c()
if(Nsig > 8){warning('Large number of signatures')}
for(k in 1:floor(Nsig/2)){
  it_partitions <- c(it_partitions, lapply(1:ncol(combn(1:Nsig, k)), function(x) combn(1:Nsig, k)[,x]))
}
pvals <- rep(NA, length(it_partitions))
ict <- 1
for(i in it_partitions){
  V <- rep(-1, Nsig)
  V[i] <- 1
  pvals[ict] <- t.test(ilr(props, V = V)[1:floor(Nsamp/2)],
         ilr(props, V = V)[(floor(Nsamp/2)+1):Nsamp])$p.value
  ict <- ict + 1
}

groups <- sapply(it_partitions, paste0, collapse='_')
ggplot(data.frame(pval=pvals, group=groups),
       aes(x=factor(group, levels=groups[order(pvals)]), y=log(pval)))+
  geom_point() + ggtitle('P value for comparing a group (x-axis)\nto its complementary')+
  labs(x='Group')
##' We expected 1 to be the one with lowest p-val
##' as this is how we created the dataset.
##' Groups containing signature 1 follow.

@

\clearpage
\section{Dimensionality reduction: PCA}
PCA is insensitive to the irl basis, so one can just use the default contrast matrix and run it with ilr, e.g.

<<PCA>>=
plotPCA(compositions::ilr(exposuresBreast560),
        groups = metadataBreast560$final.ER)
@

\section{Plotting}

\subsection{Barplots}
As seen before

\subsection{Ternary diagrams}
<<>>=
plot_ggtern(close_data(exposuresCNA_12K_TCGA, c('s1', 's2', 's6')),
            colours = factor(metadataCNA_12K_TCGA$project_id))
@

\clearpage
\printbibliography

\clearpage
\section{Session info}
<<>>=
  sessionInfo()
@

\end{document}
%
% \section{Linear model for numerical predictors}
% <<>>=
% ## This chunk was last ran in
% timestamp()
%
% tmp_merged_compositional <- new("merged_compositional",
%                                 id='adas',
%                                 id_samples=paste0("sam", 1:30),
%                                 id_signatures= c('s1', 's2', 's3', 's4'), ## signature names
%                                 count_matrix=MCMCpack::rdirichlet(30, c(1,1,1,1)),
%                                 df=data.frame(a=sample(1:1e4, 30), b=rep(10, 30)))
% comp_lm(tmp_merged_compositional)
% @
%
% \section{Importing data}
% <<>>=
% ## This chunk was last ran in
% timestamp()
%
% biplot(princomp(acomp(MCMCpack::rdirichlet(30, rep(1, 4)))))
%
% @
%
% \subsection{Testing hypotheses about two populations}
% We might have our samples split into two categories; e.g. sex. As in Aithison 1986\cite{}, I follow a hierarchy of alternative hypotheses, from least to most complex.
%
% Our first question is whether two populations have the same covariance and structure and center (i.e. if there is any distributional difference)
%
% <<>>=
% ## This chunk was last ran in
% timestamp()
% ##TODO!!
% @
%
% The next is whether the populations have a different center:
%
% <<>>=
% ## This chunk was last ran in
% timestamp()
% ## This dataset includes the two components above, as well as four others
% ## (a total of seven)
% data("two_normal_pops_extended")
%
% ## Data from the Landscape... paper
% data("Breast560")
%
% wrapper_compare_populations <- function(predictors, response, ...){
%   if(length(unique(response)) == 2){
%     tmp <- compare_populations(predictors, response, ...)
%     tmp <- tmp$info[1:2]
%     tmp
%   }
% }
%
% x <- do.call('rbind', lapply(1:ncol(metadata(Breast560)),
%        function(k){
%          wrapper_compare_populations(predictors = count_matrix(Breast560),
%                                      response = metadata(Breast560)[,k])
%          }
%        ))
%
%
% x
%
% @
%
%
% Not sure if this is correct
% <<fig.width=3.5,fig.height=5>>=
% source("../../CDA_in_Cancer/code/functions/basic_functions.R")
% plotPCA(ilr(count_matrix(Breast560)), pch=4, col='blue')
% @
%
%
% \section{Battery of tests}
%
%
% \subsection{Logistic regression}
% Based on ACDWR pg 200
%
% <<>>=
% #setwd("~/Documents/PhD/CompSign/vignette_knitr/")
% load("../data/two_normal_pops_extended.rda")
% load("../data/two_normal_pops_extended.rda")
% load("../data/CNA_12K_TCGA.rda")
%
% ## avoid perfect separation
% L <- length((as.numeric(metadata(two_normal_pops_extended)[,1])))
% scramble <- sample(1:L, floor(L*0.05), replace = FALSE)
%
% scrambled_labels <- (as.numeric(metadata(two_normal_pops_extended)[,1]))
% scrambled_labels[scramble] <- 1-scrambled_labels[scramble]
%
% auxcomp <- scale(ilr(count_matrix(two_normal_pops_extended)),
%                  center = TRUE, scale = FALSE)
%
% summary(glm(formula = scrambled_labels ~ ilr(acomp(count_matrix(two_normal_pops_extended))),
%             family = binomial(link = "logit")))
%
% res <- comp_logistic(count_matrix(two_normal_pops), scrambled_labels)
% res
%
% resB <- comp_logistic(count_matrix(two_normal_pops_extended), scrambled_labels)
% resB
%
% resCNA_gender <- comp_logistic(count_matrix(cleanObject(CNA_12K_TCGA, 'gender')),
%                               metadata(cleanObject(CNA_12K_TCGA, 'gender'))[,'gender'])
% resCNA_gender
%
% ## below: incorrect
% resCNA_race <- comp_logistic(count_matrix(cleanObject(CNA_12K_TCGA, 'race')),
%                               metadata(cleanObject(CNA_12K_TCGA, 'race'))[,'race'], relax_binary_assumption = TRUE)
%
% resCNA_race
%
% @
%
% With data from 560 BRCA:
%
% <<>>=
% load("../data/Breast560.rda")
%
% resBRCA_finalER <- comp_logistic(count_matrix(cleanObject(Breast560, 'final.ER')),
%                               metadata(cleanObject(Breast560, 'final.ER'))[,'final.ER'])
% resBRCA_finalER
% resBRCA_finalPR <- comp_logistic(count_matrix(cleanObject(Breast560, 'final.PR')),
%                                  metadata(cleanObject(Breast560, 'final.PR'))[,'final.PR'])
% resBRCA_finalPR
% @
%
% How to get p-values? I don't think the below is correct
% <<>>=
% give_pval <- function(summary_obj){
%   z <- summary_obj$coefficients/summary_obj$standard.errors
%   # 2-tailed Wald z tests to test significance of coefficients
%   p <- (1 - pnorm(abs(z), 0, 1)) * 2
%   p
% }
%
% give_pval(res$summary)             ## 1 and two are; the third one too (higher p-val) (third one wasn't expected, as far as I know?)
% give_pval(resB$summary)            ## 1 and two are; the rest are not (as expected)
% give_pval(resCNA_gender$summary)   ## are are statistically significant for the copy number signatures
% give_pval(resBRCA_finalER$summary) ## signature 1 significant
% give_pval(resBRCA_finalPR$summary) ## none are statistically significant
% give_pval(resCNA_race$summary)     ## some statistically significant
% @
%
% <<>>=
% wrapper_single_logReg <- function(colname, Ddd){
%     print('asdsd2')
%     print(head(metadata((Ddd))))
%     Ddd <- cleanObject(Ddd, colname)
%     compData = count_matrix(Ddd)
%     binaryLabels = metadata(Ddd)[,colname]
%
%     tmp <- comp_logistic(compData = compData,
%                          binaryLabels = binaryLabels,
%                          relax_binary_assumption = TRUE)
% #    give_pval(tmp$summary)
%     print(give_pval(tmp$summary))
%     cbind.data.frame(rep(colname, nrow( give_pval(tmp$summary))), give_pval(tmp$summary))
%     cbind.data.frame(rep(colname, nrow( give_pval(tmp$summary))), give_pval(tmp$summary))
% }
% wrapper_multiple_logReg <- function(dataset, colnames){
%   print('asdsd')
%   head(metadata(dataset))
%   do.call('rbind', lapply(colnames, function(X) wrapper_single_logReg(colname = X, Ddd = dataset)))
% }
%
% wrapper_single_logReg('race', CNA_12K_TCGA)
% all_cna <- wrapper_multiple_logReg(dataset = CNA_12K_TCGA,
%                                  colnames = c('race', 'ethnicity', 'gender', 'alcohol_history'))
%
% all_cna_coefs <- lapply(c('race', 'ethnicity', 'gender', 'alcohol_history'), function(lab){
%   comp_logistic(compData = count_matrix(cleanObject(CNA_12K_TCGA)),
%                 binaryLabels = metadata(cleanObject(CNA_12K_TCGA))[,lab],
%                 relax_binary_assumption = TRUE)
%   })
% ## cont...
%
% ## 'tissue_or_organ_of_origin':  too many (1260) weights
%
% library(pheatmap)
% source("../../CDA_in_Cancer/code/functions/WrapperlikeFunctions.R")
% pheatmap0(all_cna[,-1], nonames = FALSE, annotation_row = data.frame(all_cna[,1], row.names = rownames(all_cna[,-1])))
% @
%
% <<>>=
% require(reshape2)
% require(ggplot2)
% molten_pvals <- melt(all_cna)
% colnames(molten_pvals) <- c('variable', 'signature', 'value')
% ggplot(molten_pvals, aes(x=interaction(variable,signature), y=-log(value), col=signature))+
%   geom_point()+
%   geom_hline(aes(yintercept=-log(0.05)))
%
%
% ## if I want a sort of volcano plot I need the coefs (continue all_cna_coefs)
%
% @
%

\documentclass{article}

\usepackage{hyperref}

\title{Package \textbf{CompSign}}
\author{Lena Morrill}
\date{October 2017}

\begin{document}

\maketitle

\textbf{CompSign} is a package for yadayada... overlooked that mutational signatures are compositional in nature yadayada. The reference manual can be found \href{https://github.com/lm687/CompSign/blob/master/CompSign.pdf}{here}.

\tableofcontents

<<>>=
knitr::opts_chunk$set(cache = FALSE)
@

<<>>=
## This chunk was last ran in
timestamp()

## install latest version
library(devtools)
#devtools::install_github("lm687/CompSign")
library(CompSign)
library(compositions)
@

<<>>=
## if the folder data/ is not in github
for(i in list.files("../data/", pattern = "*rda", full.names = TRUE)){load(i)}
@

<<>>=
## This chunk was last ran in
timestamp()

##########################
####### Dummy data #######
##########################

### Example of matrix transformed into sign object
input_dummy <- matrix(runif(100), 4)
colnames(input_dummy) <- paste0('s', 1:25); rownames(input_dummy) <- paste0('sam', 1:4)
sign_dummy <- to_sign(input_dummy)

@

\section{Summarise the signature matrix}
<<>>=
## This chunk was last ran in
timestamp()

add_together_matrix(sign_dummy)
results_sumarise <- summarise(add_together_matrix(sign_dummy))
results_sumarise$General
@

\section{Linear model for numerical predictors}
<<>>=
## This chunk was last ran in
timestamp()

tmp_merged_compositional <- new("merged_compositional",
                                id='adas',
                                id_samples=paste0("sam", 1:30),
                                id_signatures= c('s1', 's2', 's3', 's4'), ## signature names
                                count_matrix=MCMCpack::rdirichlet(30, c(1,1,1,1)),
                                df=data.frame(a=sample(1:1e4, 30), b=rep(10, 30)))
comp_lm(tmp_merged_compositional)
@

\section{Importing data}
<<>>=
## This chunk was last ran in
timestamp()

biplot(princomp(acomp(MCMCpack::rdirichlet(30, rep(1, 4)))))

@

\section{Other}
\begin{enumerate}
\item Test for normality as follows:
<<>>=
## This chunk was last ran in
timestamp()

data(two_normal_pops)
par(mfrow=c(1,2))
qqnorm.acomp(acomp(two_normal_pops@count_matrix), pch=19, cex=0.2)
qqnorm.acomp(acomp(two_normal_pops@count_matrix[1:1000,]), pch=19, cex=0.2, plot.it=FALSE)
@
\end{enumerate}

\section{Clustering of samples}

<<>>=


@

\clearpage

\subsection{Testing hypotheses about two populations}
We might have our samples split into two categories; e.g. sex. As in Aithison 1986\cite{}, I follow a hierarchy of alternative hypotheses, from least to most complex.

Our first question is whether two populations have the same covariance and structure and center (i.e. if there is any distributional difference)

<<>>=
## This chunk was last ran in
timestamp()
##TODO!!
@

The next is whether the populations have a different center:

<<>>=
## This chunk was last ran in
timestamp()
## This dataset includes the two components above, as well as four others
## (a total of seven)
data("two_normal_pops_extended")

## Data from the Landscape... paper
data("Breast560")

wrapper_compare_populations <- function(predictors, response, ...){
  if(length(unique(response)) == 2){
    tmp <- compare_populations(predictors, response, ...)
    tmp <- tmp$info[1:2]
    tmp
  }
}

x <- do.call('rbind', lapply(1:ncol(metadata(Breast560)),
       function(k){
         wrapper_compare_populations(predictors = count_matrix(Breast560),
                                     response = metadata(Breast560)[,k])
         }
       ))


x

@

\section{Datasets}
\subsection{Data for 560 breast cancer patients}
Data from 560 breast cancer patients is available as part of the document as well:

<<>>=
data("Breast560")
metadata(Breast560)[1:4,1:5]
count_matrix(Breast560)[1:4,1:5]
@

Not sure if this is correct
<<fig.width=3.5,fig.height=5>>=
source("../../CDA_in_Cancer/code/functions/basic_functions.R")
plotPCA(ilr(count_matrix(Breast560)), pch=4, col='blue')
@


\subsection{Data for 12k TCGA samples, with ovarian cancer-derived CNA signatures}

<<>>=
timestamp()
data("CNA_12K_TCGA")

dim(metadata(CNA_12K_TCGA))
dim(count_matrix(CNA_12K_TCGA))
@

\section{Battery of tests}
\subsection{(ongoing) test for equality}

<<>>=
comp.test(x = count_matrix(Breast560),
                              ina = as.numeric(as.factor(metadata(Breast560)$final.ER)),
                              test = "james", R = 0)
@


\subsection{Logistic regression}
Based on ACDWR pg 200

<<>>=
#setwd("~/Documents/PhD/CompSign/vignette_knitr/")
load("../data/two_normal_pops_extended.rda")
load("../data/two_normal_pops_extended.rda")
load("../data/CNA_12K_TCGA.rda")

## avoid perfect separation
L <- length((as.numeric(metadata(two_normal_pops_extended)[,1])))
scramble <- sample(1:L, floor(L*0.05), replace = FALSE)

scrambled_labels <- (as.numeric(metadata(two_normal_pops_extended)[,1]))
scrambled_labels[scramble] <- 1-scrambled_labels[scramble]

auxcomp <- scale(ilr(count_matrix(two_normal_pops_extended)),
                 center = TRUE, scale = FALSE)

summary(glm(formula = scrambled_labels ~ ilr(acomp(count_matrix(two_normal_pops_extended))),
            family = binomial(link = "logit")))

res <- comp_logistic(count_matrix(two_normal_pops), scrambled_labels)
res

resB <- comp_logistic(count_matrix(two_normal_pops_extended), scrambled_labels)
resB

resCNA_gender <- comp_logistic(count_matrix(cleanObject(CNA_12K_TCGA, 'gender')),
                              metadata(cleanObject(CNA_12K_TCGA, 'gender'))[,'gender'])
resCNA_gender

## below: incorrect
resCNA_race <- comp_logistic(count_matrix(cleanObject(CNA_12K_TCGA, 'race')),
                              metadata(cleanObject(CNA_12K_TCGA, 'race'))[,'race'], relax_binary_assumption = TRUE)

resCNA_race

@

With data from 560 BRCA:

<<>>=
load("../data/Breast560.rda")

resBRCA_finalER <- comp_logistic(count_matrix(cleanObject(Breast560, 'final.ER')),
                              metadata(cleanObject(Breast560, 'final.ER'))[,'final.ER'])
resBRCA_finalER
resBRCA_finalPR <- comp_logistic(count_matrix(cleanObject(Breast560, 'final.PR')),
                                 metadata(cleanObject(Breast560, 'final.PR'))[,'final.PR'])
resBRCA_finalPR
@

How to get p-values? I don't think the below is correct
<<>>=
give_pval <- function(summary_obj){
  z <- summary_obj$coefficients/summary_obj$standard.errors
  # 2-tailed Wald z tests to test significance of coefficients
  p <- (1 - pnorm(abs(z), 0, 1)) * 2
  p
}

give_pval(res$summary)             ## 1 and two are; the third one too (higher p-val) (third one wasn't expected, as far as I know?)
give_pval(resB$summary)            ## 1 and two are; the rest are not (as expected)
give_pval(resCNA_gender$summary)   ## are are statistically significant for the copy number signatures
give_pval(resBRCA_finalER$summary) ## signature 1 significant
give_pval(resBRCA_finalPR$summary) ## none are statistically significant
give_pval(resCNA_race$summary)     ## some statistically significant
@

<<>>=
wrapper_single_logReg <- function(colname, Ddd){
    print('asdsd2')
    print(head(metadata((Ddd))))
    Ddd <- cleanObject(Ddd, colname)
    compData = count_matrix(Ddd)
    binaryLabels = metadata(Ddd)[,colname]

    tmp <- comp_logistic(compData = compData,
                         binaryLabels = binaryLabels,
                         relax_binary_assumption = TRUE)
#    give_pval(tmp$summary)
    print(give_pval(tmp$summary))
    cbind.data.frame(rep(colname, nrow( give_pval(tmp$summary))), give_pval(tmp$summary))
    cbind.data.frame(rep(colname, nrow( give_pval(tmp$summary))), give_pval(tmp$summary))
}
wrapper_multiple_logReg <- function(dataset, colnames){
  print('asdsd')
  head(metadata(dataset))
  do.call('rbind', lapply(colnames, function(X) wrapper_single_logReg(colname = X, Ddd = dataset)))
}

wrapper_single_logReg('race', CNA_12K_TCGA)
all_cna <- wrapper_multiple_logReg(dataset = CNA_12K_TCGA,
                                 colnames = c('race', 'ethnicity', 'gender', 'alcohol_history'))

all_cna_coefs <- lapply(c('race', 'ethnicity', 'gender', 'alcohol_history'), function(lab){
  comp_logistic(compData = count_matrix(cleanObject(CNA_12K_TCGA)),
                binaryLabels = metadata(cleanObject(CNA_12K_TCGA))[,lab],
                relax_binary_assumption = TRUE)
  })
## cont...

## 'tissue_or_organ_of_origin':  too many (1260) weights

library(pheatmap)
source("../../CDA_in_Cancer/code/functions/WrapperlikeFunctions.R")
pheatmap0(all_cna[,-1], nonames = FALSE, annotation_row = data.frame(all_cna[,1], row.names = rownames(all_cna[,-1])))
@

<<>>=
require(reshape2)
require(ggplot2)
molten_pvals <- melt(all_cna)
colnames(molten_pvals) <- c('variable', 'signature', 'value')
ggplot(molten_pvals, aes(x=interaction(variable,signature), y=-log(value), col=signature))+
  geom_point()+
  geom_hline(aes(yintercept=-log(0.05)))


## if I want a sort of volcano plot I need the coefs (continue all_cna_coefs)

@

\end{document}
